# Введение

## Цель работы

Познакомиться с оболочкой bash и утилитами, используемыми IT–специалистом в повседневной жизни.

В данной курсовой работе мы познакомимся с фильтрами, которые позволяют строить сложные конвейеры для манипуляций с текстом.  Мы узнаем, как выводить текст, сортировать его, выполнять подсчет слов и строк, преобразовывать символы, а также многое другое.  

**Фильтрация текста** – это процесс получения входного текстового потока, выполнения неких преобразований над ним и передача измененных данных в выходной поток. Хотя входные или выходные данные могут поступать из файлов, в UNIX® и Linux фильтрация обычно осуществляется путем составления конвейеров из команд, в которых вывод одной команды передается по программному каналу (или перенаправляется) на вход следующей команде.

В рамках данной курсовой работы представлена информация о наиболее часто используемых фильтрах. В результате комбинирования простых команд и фильтров с использованием программных каналов могут быть созданы элегантные решения.

К числу команд-фильтров относятся `grep`, `ack`, `awk`, `sort`, `uniq`, `ws`, `tr`. Далее рассмотрим их более подробно.

## Создание файлов

* Переходим в директорию рабочего стола
* Создаем папку `kyrsovay2018`
* Переходим в созданную директорию
* Создаем файл `tanya.txt` в данной директории
* Заносим данные в файл
* Создаем файл `ksenya.txt` в данной директории
* Заносим данные в файл

**тут картинка**

В курсовой работе используются не только два файла. Эти файлы приведены в качестве примера.

## grep

Команда `grep`, одна из самых известных и употребительных команд Unix-подобных ОС, ведет свое начало от первого текстового Unix-редактора - `ed`. В этом редакторе была команда **g/re/p (global/regular expression/print)**, которая и дала свое название новой программе.

Утилита `grep` осуществляет во входных данных поиск строк, совпадающих с данным выражением (данными выражениями). Если строка ввода совпадает с любым из выражений, она считается "выбранной". По умолчанию выбранные строки записываются в стандартный поток вывода. 

Утилита `grep` распознает три типа регулярных выражений: базовые, расширенные и фиксированные.

Базовые и расширенные регулярные выражения аналогичны арифметическим выражениям, в которых крупные выражения формируются путем объединения более мелких выражений и операторов по установленному правилу приоритетов. В регулярных выражениях присутствует "невидимый" оператор, т.е. конкатенация. Конкатенация двух выражений означает сопоставление лево, а затем правой части. Наименьшим выражением является один символ. 

**Команда `grep` может обрабатывать любое количество файлов одновременно. Возьмем два исходных файла, которые мы создали.**

```
bash
grep '5' tanya.txt ksenya.txt
```

**тут картинка**

В выводе перечислены файлы, и указано, в каком из них какая строка содержит символ «5». Символ пришлось взять в кавычки, чтобы командный интерпретатор понял, что имеется в виду символ, а не условный знак. Команда `grep` вовсе не ограничена одним выражением, можно задавать хоть целые фразы. Только их тоже нужно заключать в кавычки (одинарные или двойные).

```
bash
grep 'e f' tanya.txt ksenya.txt
```

**тут картинка**

### Опции grep

#### 1. Опция -i (--ignore-case)

**Приказывает команде игнорировать регистр символов, таким образом, поиск будет производиться как среди заглавных, так и среди строчных букв.**

```
bash
grep -i 'w' tanya.txt ksenya.txt
```

**тут картинка**

Изначально была задана строчная буква **'w'**, а на экран произошел вывод как строчных, так и заглавных букв **'w'**

#### 2. Опция -c (--count)

**Эта опция не выводит строки, а подсчитывает количество строк, в которых обнаружена заданная конфигурация символов.**

```
bash
grep -c 'a' tanya.txt ksenya.txt
```

**тут картинка**

То есть в двух строках файла tanya.txt и трех строках файла ksenya.txt встречается сочетание символа **«а»**.

#### 3. Опция -n (--line-number)

**При использовании этой опции вывод команды `grep` будет указывать номера строк, содержащих заданную конфигурацию.**

```
bash
grep -n 'ou' tanya.txt ksenya.txt
```

**тут картинка**

Во второй и четвертой строках файла tanya.txt найдено сочетание **'ou'**

#### 4. Опция -v (--invert-match)

**Выполняет работу, обратную обычной - выводит строки, в которых заданная конфигурация не встречается.**

```
bash
grep -v 'ewq' tanya.txt ksenya.txt
```

**тут картинка**

Во всех строках, которые выведены на экран, нет конфигурации символов **'ewq'**.

#### 5. Опция -w (--word-regexp)

**Заставит команду `grep` искать только строки, содержащие все слово или фразу, составляющую данную конфигурацию.**

```
bash
grep -w 'ar' tanya.txt ksenya.txt
```

**тут картинка**

Вывода нет, то есть не нашлись строки, содержащих выражение **"ar"**. 

А вот в данном случае:

**тут картинка**  

Команда находит точное соответствие в файле ksenia.txt.

#### 6. Опция -x (--line-regexp)

**Еще более строгая команда. Она отберет только те строки исследуемого файла или файлов, которые полностью совпадают с заданной конфигурацией.**

```
bash
grep -x 'Woy' tanya.txt ksenya.txt
```

**тут картинка**  

Строгое совпадение нашлось только в файле ksenya.txt. Это строка **'Woy'**

#### 7. Опция -l (--files-with-matches)

**Команда `grep` с этой опцией не возвращает строки, содержащие заданную конфигурацию, а сообщает лишь имена файлов, в которых данный образец найден.**

```
bash
grep -l 'Tanya' tanya.txt ksenya.txt
```

**тут картинка**  

Конфигурация символов ‘Tanya’ была найдена только в файле tanya.txt. Стоит отметить, что сканирование каждого из заданных файлов продолжается только до первого совпадения с заданной конфигурацией.

#### 8. Опция -L (--files-without-match)

Эта команда наоборот, сообщает имена тех файлов, где не встретилась заданная конфигурация.

```
bash
grep -L 'Tanya' tanya.txt ksenya.txt
```

**тут картинка**  

Конфигурация символов **'Tanya'** была не найдена только в файле ksenya.txt

Команда `grep` настолько полезна, многофункциональна и проста в употреблении, что, однажды познакомившись с ней, невозможно представить себе работы без нее. 

## ack

Инструмент ack был разработан специально для поиска исходного кода программ. Потому ack ищет определенные файлы и игнорирует другие.

К примеру, при поиске структуры каталогов проекта иерархия репозитория системы управления версиями, как правило, не нужна. Она содержит информацию о более старых версиях файла и, скорее всего, приведет к многочисленным повторам. Ack понимает, что здесь искать не нужно, поэтому он игнорирует эти каталоги, благодаря чему результат получается более сжатым и содержит меньше ошибочных данных.

Подобным образом он игнорирует общие резервные файлы, созданные некоторыми текстовыми редакторами. Также нет смысла искать с помощью ack некоторые файлы, которые обычно встречаются в исходных каталогах: сжатые версии веб-файлов, изображения, PDF-файлы и т.д. Все эти функции положительно влияют на результаты почти каждого поиска.     Кроме того, эти настройки всегда можно изменить.

Для начала нужно установить инструмент ack на сервер. На сервере Ubuntu или Debian это так же просто, как установить утилиту из репозитория по умолчанию. Пакет называется `ack-grep`:

```
bash
sudo apt update
sudo apt install ack-grep
```

Поскольку исполняемый файл также называется `ack-grep`, можно сказать системе сократить его имя до `ack`, чтобы использовать его в командной строке, введя следующую команду:

```
bash
dpkg-divert --local --divert /usr/bin/ack --rename --add /usr/bin/ack-grep
```

Теперь инструмент будет отвечать на имя `ack` вместо `ack-grep`. 


**Вывести файлы в которых был найден указанный шаблон.**


```
bash
ack w
```

**тут картинка** 

Данная команда нашла все файлы, в которых встречается шаблон **'w'**.

## Опции ack

#### 1. Опция -f

Узнать количество файлов в директории, в которой мы сейчас находимся.

```
bash
ack -f | wc -l
```

**тут картинка**

В данной директории было найдено 4 файла.

#### 2. Опция -w

Найти файлы, в которых слова четко совпадают с границами шаблона. 

```
bash
ack -w We
```

**тут картинка**

Точное совпадение нашлось только в файле `tanya.txt`.

#### 3. Опция -ch

Узнать общее количество найденных совпадений с шаблоном в файлах.

```
bash
ack -ch a
```

**тут картинка**  

В файлах, данной директории, нашлось 19 совпадений указанного шаблона **'a'**.

#### 4. Опция -c

Узнать количество совпадений с шаблоном в каждом файле.

```
bash
ack -c a
```

**тут картинка**  

Шаблон “а” был встречен в файле `ksenya.txt` 5 раз, в файле `povtor.txt` 0 раз , в файлах `dolgi.txt` и `tanya.txt` по 7 раз.

## 4. awk

Утилита `awk`, или точнее `GNU awk`, в сравнении с `sed`, выводит обработку потоков данных на более высокий уровень. Благодаря awk в нашем распоряжении оказывается язык программирования, а не довольно скромный набор команд, отдаваемых редактору. С помощью языка программирования `awk` можно выполнять следующие действия:

* объявлять переменные для хранения данных;
* использовать арифметические и строковые операторы для работы с данными;
* использовать структурные элементы и управляющие конструкции языка, такие, как оператор `if-then` и циклы, что позволяет реализовать сложные алгоритмы обработки данных;
* создавать форматированные отчёты.

Если говорить лишь о возможности создавать форматированные отчёты, которые удобно читать и анализировать, то это оказывается очень кстати при работе с лог-файлами, которые могут содержать миллионы записей. Но `awk` — это намного больше, чем средство подготовки отчётов.

Схема вызова `awk` выглядит так:

```
bash
awk options program file
```

`Awk` воспринимает поступающие к нему данные в виде набора записей. Записи представляют собой наборы полей. Упрощенно, если не учитывать возможности настройки `awk` и говорить о некоем вполне обычном тексте, строки которого разделены символами перевода строки, запись — это строка. Поле — это слово в строке.

Одна из основных функций `awk` заключается в возможности манипулировать данными в текстовых файлах. Делается это путём автоматического назначения переменной каждому элементу в строке. По умолчанию `awk` назначает следующие переменные каждому полю данных, обнаруженному им в записи:

```
$0 — представляет всю строку текста (запись).
$1 — первое поле.
$2 — второе поле.
$n — n-ное поле.
```

Поля выделяются из текста с использованием символа-разделителя. По умолчанию — это пробельные символы вроде пробела или символа табуляции.

Рассмотрим использование этих переменных на простом примере. А именно, обработаем файл, в котором содержится несколько строк.


**Вывести только первый столбец в указанном файле. Где разделителем столбцов по умолчанию считается пробел.**

```
bash
awk '{print $1}' ksenya.txt
```

**тут картинка**  

Данная команда вывела первые слова (первые поля) каждой записи, содержащиеся в файле `ksenya.txt`.

## Опции awk

#### 1. Опция -F

**Вывести поля, в которых используется указанный в команде разделитель. Текст файла text.txt:**

```
Hello, my name is Ksenya.
My friends is Tanya, Lina, Julia, Poly.
```

В качестве разделителя зададим символ **','**.

```
bash
awk -F, '{print $1}' text.txt
```

**тут картинка**  

Данная команда вывела первые поля файла `text.txt`, считая в качестве символа разделителя (конца поля) символ **','**.

#### 2. Опция -v

Передать в программу переменную, а именно константу.

```
bash
awk -v pi=3.1415 '{print $1}'
```

**тут картинка**  

В результате работы команды было выведено число, занесённое нами в константу.

#### 3. Опция -f

**Использовать скрипты, хранящиеся в файлах, и обратиться к ним в команде.**

Подготовим файл text1.txt, в который запишем следующее содержимое:

```
{print $1 "*" $2}
```
Вызовем awk, указав этот файл в качестве источника команд

```
bash
awk -F, -f text1.txt text.txt'
```

**тут картинка**  

В качестве разделителя строк мы указали символ **','**. Поэтому в ходе выполнения команды, между первым и вторым полем разделитель поменялся на символ **'\*'**, который мы указали в файле источника команд `text1.txt`.

#### 4. length

Получить длину каждой строки, использую ключ `length`.

```
bash
awk '{print length}' text.txt'
```

**тут картинка**  

В файле text.txt, в первом предложении количество символов **25**, во втором **39**.

#### 4. BEGIN/END

Вывести перед файлом и после него указанные данные.

```
bash
awk 'BEGIN {print "--------------------"} {print $0} END {print "BYE"}' text.txt'
```

**тут картинка**  

В результате выполнения данной команды, в начало и конец файла `text.txt`, который мы выводим полностью (указав `$0`), будут добавлены строки указанные в команде.

`awk` - это мощнейший инструмент обработки данных, масштабы которого сопоставимы с отдельным языком программирования.

## 5. sort

Команда `sort` сортирует содержимое файла в алфавитном или нумерологическом порядке. Если задать несколько файлов, то команда `sort` соединит их и, рассортировав, выдаст единым выводом. По умолчанию, объектом сортировки будут строки, однако опции позволяют выбирать объект сортировки: колонки, столбцы и прочие элементы форматирования файла. Разделителем между ними служат пробелы, однако соответствующие опции позволяют задать иные разделители.

Команда `sort` весьма древняя, она может служить образцом программирования утилит в ранних 70-х годах прошлого века.
Составим список долгов и запишем их в файл dolgi.txt

**тут картинка**  

Сделать сортировку по имени в алфавитном порядке.

```
bash
sort dolgi.txt'
```

**тут картинка**  

Произошла сортировка имен в алфавитном порядке.

## Опции sort

#### 1. Опция -r

Эта опция позволяет сортировать файл в порядке обратном алфавитному.

```
bash
sort -r dolgi.txt
```

**тут картинка**  

Произошла сортировка имен в порядке обратном алфавитному.
 