СИС Лекция 4

Тема: Системные вызовы. Менеджмент процессов в Linux. Parent, child, fork - процессы. Абсолютный и относительные приоритеты.

Систе́мный вы́зов (system call) в программировании и вычислительной технике — обращение прикладной программы к ядру операционной системы для выполнения какой-либо операции.
Современные операционные системы (ОС) предусматривают разделение времени между выполняющимися вычислительными процессами (многозадачность) и разделение полномочий, препятствующее обращению исполняемых программ к данным других программ и оборудованию. Ядро ОС исполняется в привилегированном режиме работы процессора. Для выполнения межпроцессной операции или операции, требующей доступа к оборудованию, программа обращается к ядру, которое, в зависимости от полномочий вызывающего процесса, исполняет либо отказывает в исполнении такого вызова.
С точки зрения программиста, системный вызов обычно выглядит как вызов подпрограммы или функции из системной библиотеки. Однако системный вызов, как частный случай вызова такой функции или подпрограммы, следует отличать от более общего обращения к системной библиотеке, поскольку последнее может и не требовать выполнения привилегированных операций.



В заголовочном файле ядра Linux sys/syscall.h доступна функция syscall, позволяющая непосредственно выполнять системные вызовы. Таблица системных вызовов Linux документирована и является частью API этой ОС.
Промежуточная библиотека
Как правило, система предоставляет библиотеку или API, которые находятся между обычным приложением и ОС. Такая библиотека предоставляет программисту удобный интерфейс для работы с ОС в виде интерфейсных функций. Интерфейсные функции библиотеки предоставляют обычные соглашения о вызове функций для использования системных вызовов и делают системные вызовы более унифицированными. Обращение к функции такой библиотеки само по себе не вызывает переключения в режим ядра и является обычным вызовом подпрограммы.
Примеры и инструменты
В Unix, Unix-like и других POSIX-совместимых операционных системах популярными системными вызовами являются: open, read, write, close, wait, exec, fork, exit и kill. Многие современные ОС имеют сотни системных вызовов. Например, Linux и OpenBSD каждые имеют порядка 380 разных вызовов,[1][2] NetBSD имеет около 500,[3] FreeBSD имеет более 500,[4] в то время как Plan 9 имеет 51.[5]
Инструменты, такие как strace, sysdig и truss наблюдают за исполнением процесса с самого начала и выводят все системные вызовы этого процесса или могут присоединяться к уже работающему процессу и перехватывают все системные вызовы, сделанные этим процессом, если операции не нарушают пользовательские разрешения.
Типичные реализации
Реализация системных вызовов требует передачи управления, которая предполагает некоторые специфические для определённой архитектуры детали. Классический способ реализации — использование прерываний (interruption, trap). Прерывания передают управление ядру ОС, при этом приложению нужно внести в определённые регистры процессора номер системного вызова и необходимые аргументы и выполнить инструкцию генерации программного прерывания.
Для многих RISC-процессоров это единственный способ, но архитектуры группы CISC (в том числе, широко используемые x86 и x86 64) имеют дополнительные методы. Например, специальные инструкции SYSCALL/SYSRET или SYSENTER/SYSEXIT (эти два механизма были разработаны независимо друг от друга AMD и Intel соответственно, но, по сути, выполняют одинаковые функции). Это инструкции «быстрой» передачи управления, которые разработаны для передачи управления к ОС для системных вызовов без прерываний.

Категории системных вызовов
Системные вызовы могут быть сгруппированы в пять больших категорий:
Управление процессами
load
execute
end (exit), abort
создание процесса (fork в Unix-like, NtCreateProcess в Windows_NT Native API)
завершение процесса
get/set process attributes
wait время, события, signal события
allocate, free memory
Работа с файлами
create file, delete file
open, close
read, write, reposition
get/set file attributes
Управление устройствами
request device, release device
read, write, reposition
get/set device attributes
logically attach or detach devices
Работа с информацией
get/set time or date
get/set system data
get/set process, file, or device attributes
Связь, коммуникация
create, delete communication connection
send, receive messages
transfer status information
attach or detach remote devices
Режим процессора и переключение контекста
Системные вызовы в Unix-подобных системах обрабатываются в режиме ядра, которое завершается повышением режима выполнения процессора в более привилегированный, но изменение контекста процесса не требуется — однако при этом происходит изменение контекста привилегии. Системные ресурсы работают с учётом режима исполнения в соответствии со статусом регистра процессора и процессы — это своего рода абстракция, предоставляемая ОС. Системный вызов обычно не требует изменения контекста на другой процесс, напротив, он выполняется в контексте того процесса, который его вызвал.
В многопотоковых процессах системные вызовы могут исходить из разных потоков. Обработка таких системных вызовов полностью зависит от архитектуры ОС. Ниже приведены типичные модели, которые используются ядрами:
Модель многие-к-одному: все системные вызовы от любого пользовательского потока в процессе обрабатываются одним потоком уровня ядра. У этой системы есть один серьёзный недостаток — любой блокирующий системный вызов (например, ожидание ввода пользователя) может остановить остальные потоки. Также эта модель не может использовать многоядерные процессоры.
Модель один-к-одному: каждый поток пользователя во время системного вызова присоединяется к своему собственному потоку. Эта модель решает проблему блокирования системных вызовов. Она применяется в большинстве дистрибутивов Linux, Windows, Solaris последних версий.
Модель многие-к-многим: в этой модели во время системного вызова множество пользовательских потоков увязываются с множеством потоков уровня ядра.
Гибридная модель: в этой модели реализованы модели «многие-к-многим» и «один-к-одному» в зависимости от выбора ядра ОС.

Управление процессами
Первым делом научимся определять, какие процессы в системе запущены. Для этого в Linux (как и во всех UNIX-системах) имеется команда ps. Если ее запустить без всяких параметров, то она выдает список процессов, запущенных в текущей сессии. Если вы хотите увидеть список всех процессов, запущенных в системе, надо задать ту же команду с параметром -ax.
Команда ps

ps [-опции]

Первая группа опций регулирует вывод команды. Независимо от наличия опций этой группы команда ps выдает для каждого процесса отдельную строку, но содержимое этой строки может быть разным. В зависимости от заданных опций могут присутствовать следующие поля:
USER — имя владельца процесса;
    
PID — идентификатор процесса в системе;
    
PPID — идентификатор родительского процесса;
    
%CPU — доля времени центрального процессора (в     процентах), выделенного данному процессу;
    
%MEM — доля реальной памяти (в процентах),     используемая данным процессом;
    
VSZ — виртуальный размер процесса (в килобайтах);
    
RSS — размер резидентного набора (количество     1K-страниц в памяти);
    
STIME — время старта процесса;
    
TTY — указание на терминал, с которого запущен     процесс;
    
S или STAT — статус процесса;
    
PRI — приоритет планирования;
    
NI — значение nice (см. описание команды     nice     ниже);
    
TIME — сколько времени центрального процессора     занял данный процесс;
    
CMD или COMMAND — командная строка запуска     программы, выполняемой данным процессом;
а также и другие поля, полный список которых приведен на man-странице, посвященной команде ps.
Значения, выводимые в большинстве этих полей вы поймете без дополнительных пояснений. В поле Статус процесса, как уже говорилось выше, могут стоять следующие значения:
R — выполнимый процесс, ожидающий только момента,     когда планировщик задач выделит ему очередной квант времени;
    
S — процесс "спит";
    
D — процесс находится в состоянии подкачки на     диске;
    
T — остановленный процесс;
    
Z — процесс-зомби.
Рядом с указателем статуса могут стоять дополнительные символы из следующего набора:
W — процесс не имеет резидентных страниц;
    
< — высоко-приоритетный процесс;
    
N — низко-приоритетный процесс;
    
L — процесс имеет страницы, заблокированные в     памяти.
Вторая группа опций регулирует то, какие именно процессы включаются в вывод команды. Чтобы получить список всех процессов надо использовать команду ps с опциями ax или –A. Вывод в этих двух случаях отличается только в поле CMD: в первом случае выдается полная командная строка запуска программы, а во втором — только имя запущенной программы.
Описание всех опций программы ps здесь привести невозможно. Поэтому приведем только несколько примеров ее применения, которые покажут, как пользоваться этой командой в типичных ситуациях.
Для того чтобы увидеть все процессы в системе, используя стандартную форму вывода:
[user]$ ps –e
Можно к той же команде добавить опцию –o, после которой указать через запятую, какие именно поля вы хотите видеть в выводе команды:
[user]$ ps –eo pid,user,cmd
Для того, чтобы увидеть все процессы в системе, используя форму вывода BSD-систем:
[user]$ ps ax
Для того, чтобы увидеть все процессы в системе, с применением графического отображения отношения "предок-потомок":
[user]$ ps –ef
Впрочем, для того, чтобы увидеть "лес" деревьев "предок-потомок", лучше воспользоваться очень интересным аналогом команды ps –ef — командой pstree.
Для того, чтобы увидеть, сколько % ЦПУ и памяти занимают запущенные вами процессы:
[user]$ ps –u
Чтобы узнать приоритет процесса и значение nice, воспользуйтесь опцией -l:
[user]$ ps –l
Команда top и htop
Команда ps позволяет сделать как бы "моментальный снимок" процессов, запущенных в системе. В отличие от ps команда top отображает состояние процессов и их активность "в реальном режиме времени". На рисунке ниже изображено окно терминала, в котором запущена программа top.

htop — компьютерная программа, предназначенная для вывода на терминал списка запущенных процессов и информации о них (монитор процессов). Создана, как альтернатива программы top. Написана на языке Си. Предоставляет пользователю текстовый интерфейс; для вывода на терминал использует библиотеку ncurses. За изображение top следует вывод htop.

Внешний вид top

Внешний вид htop
Как видите, в верхней части окна отображается астрономическое время, время, прошедшее с момента запуска системы, число пользователей в системе, число запущенных процессов и число процессов, находящихся в разных состояниях, данные об использовании ЦПУ, памяти и свопа. А далее идет таблица, характеризующая отдельные процессы. Число строк, отображаемых в этой таблице, определяется размером окна: сколько строк помещается, столько и выводится. Графы таблицы обозначены так же, как поля вывода команды ps (см.разд. 8.4.1), так что дополнительных пояснений здесь не требуется.
Содержимое окна обновляется каждые 5 секунд. Список процессов может быть отсортирован по используемому времени ЦПУ (по умолчанию), по использованию памяти, по PID, по времени исполнения. Переключать режимы отображения можно с помощью команд, которые программа top воспринимает. Это следующие команды (просто нажимайте соответствующие клавиши, только с учетом регистра, то есть вместе с клавишей Shift):
<Shift>+<N> —     сортировка по PID;     
<Shift>+<A> —     сортировать процессы по возрасту;     
<Shift>+<P> —     сортировать процессы по использованию ЦПУ;     
<Shift>+<M> —     сортировать процессы по использованию памяти;     
<Shift>+<T> —     сортировка по времени выполнения.
Кроме команд, определяющих режим сортировки, команда top воспринимает еще ряд команд, которые позволяют управлять процессами в интерактивном режиме. С помощью команды <K> можно завершить некоторый процесс (его PID будет запрошен), а с помощью команды <R> можно переопределить значение nice для некоторого процесса. Таким образом, эти две команды аналогичны командам kill и renice.

Приоритеты, значение nice и команда renice
О том, что такое приоритет, мы уже кратко говорили в начале этой главы, Но некоторые факты надо изложить дополнительно. Приоритет для каждого процесса устанавливается в тот момент, когда процесс порождается. Приоритет процесса определяется так называемым "значением nice", которое лежит в пределах от +20 (наименьший приоритет, процесс выполняется только тогда, когда ничто другое не занимает процессор), до -20 (наивысший приоритет).
Значение nice устанавливается для каждого процесса в момент порождения этого процесса и при обычном запуске команд или программ принимается равным приоритету родительского процесса. Но существует специальная команда nice, которая позволяет изменять значение nice при запуске программы. Формат использования этой программы:
nice [- adnice] command [args]
где adnice — значение (от –20 до +19), добавляемое к значению nice процесса-родителя. Полученная сумма и будет значением nice для запускаемого процесса. Отрицательные значения может устанавливать только суперпользователь. Если опция — adnice не задана, то по умолчанию для процесса-потомка устанавливается значение nice, увеличенное на 10 по сравнению со значением nice родительского процесса. Очевидно, что если вы не суперпользователь, то применять эту команду имеет смысл только тогда, когда вы хотите запустить некий процесс с низким значением приоритета.
Другая команда, renice, служит для изменения значения nice для уже выполняющихся процессов. Ее формат таков:
renice priority [[-p] PID] [[-g] grp] [[-u] user]
Например, команда
[root]# renice -1 987 –u daemon –p 32
увеличивает на 1 приоритет процессов с PID 987 и 32, а также всех процессов пользователя daemon.
Суперпользователь может изменить приоритет любого процесса в системе. Другие пользователи могут изменять значение приоритета только для тех процессов, для которых данный пользователь является владельцем. При этом обычный пользователь может только уменьшить значение приоритета (увеличить значение nice), но не может увеличить приоритет, даже для возврата значения nice к значению, устанавливаемому по умолчанию. Поэтому процессы с низким приоритетом не могут породить "высокоприоритетных детей".
Сигналы и команда kill
Сигналы — это средство, с помощью которого процессам можно передать сообщения о некоторых событиях в системе. Сами процессы тоже могут генерировать сигналы, с помощью которых они передают определенные сообщения ядру и другим процессам. С помощью сигналов можно осуществлять такие акции управления процессами, как приостановка процесса, запуск приостановленного процесса, завершение работы процесса. Всего в Linux существует 63 разных сигнала, их перечень можно посмотреть по команде
[user]$ kill –l
Сигналы принято обозначать номерами или символическими именами. Все имена начинаются на SIG, но эту приставку иногда опускают: например, сигнал с номером 1 обозначают или как SIGHUP, или просто как HUP.
Когда процесс получает сигнал, то возможен один из двух вариантов развития событий. Если для данного сигнала определена подпрограмма обработки, то вызывается эта подпрограмма. В противном случае ядро выполняет от имени процесса действие, определенное по умолчанию для данного сигнала. Вызов подпрограммы обработки называется перехватом сигнала. Когда завершается выполнение подпрограммы обработки, процесс возобновляется с той точки, где был получен сигнал.
Можно заставить процесс игнорировать или блокировать некоторые сигналы. Игнорируемый сигнал просто отбрасывается процессом и не оказывает на него никакого влияния. Блокированный сигнал ставится в очередь на выдачу, но ядро не требует от процесса никаких действий до разблокирования сигнала. После разблокирования сигнала программа его обработки вызывается только один раз, даже если в течение периода блокировки данный сигнал поступал несколько раз.
В таблице  приведены некоторые из часто встречающихся сигналов.



Как видите, некоторые сигналы можно сгенерировать с помощью определенных комбинаций клавиш. Но такие комбинации существуют не для всех сигналов. Зато имеется команда kill, которая позволяет послать заданному процессу любой сигнал. Как уже было сказано, с помощью этой команды можно получить список всех возможных сигналов, если указать опцию -l. Если после этой опции указать номер сигнала, то будет выдано его символическое имя, а если указать имя, то получим соответствующий номер.
Для посылки сигнала процессу (или группе процессов) можно воспользоваться командой kill в следующем формате:
[user]$ kill [-сигн] PID [PID..]
где сигн — это номер сигнала, причем если указание сигнала опущено, то посылается сигнал 15 (TERM — программное завершение процесса). Чаще всего используется сигнал 9 (KILL), с помощью которого суперпользователь может завершить любой процесс. Но сигнал этот очень "грубый", если можно так выразиться, поэтому его использование может привести к нарушению порядка в системе. Поэтому в большинстве случаев рекомендуется использовать сигналы TERM или QUIT, которые завершают процесс более "мягко".
Естественно, что наиболее часто команду kill вынужден применять суперпользователь. Он должен использовать ее для уничтожения процессов-зомби, зависших процессов (они показываются в листинге команды ps как <exiting>), процессов, которые занимают слишком много процессорного времени или слишком большой объем памяти и т. д. Особый случай — процессы, запущенные злоумышленником. Но обсуждение этого особого случая выходит за рамки данной книги.
Перевод процесса в фоновый режим
Если вы запускаете какой-то процесс путем запуска программы из командной строки, то обычно процесс запускается, как говорят, "на переднем плане". Это значит, что процесс "привязывается" к терминалу, с которого он запущен, воспринимая ввод с этого терминала и осуществляя на него вывод. Но можно запустить процесс в фоновом режиме, когда он не связан с терминалом. Для запуска процесса в фоновом режиме в конце командной строки запуска программы добавляют символ &.
В оболочке bash имеются две встроенные команды, которые служат для перевода процессов на передний план или возврата их в фоновый режим. Но прежде, чем рассказывать об этих командах, надо рассказать о команде jobs. Она всегда вызывается без аргументов и показывает задания, запущенные из текущего экземпляра shell. В начале каждой строки вывода этой команды указывается порядковый номер задания в виде числа в квадратных скобках. После номера указывается состояние процесса: stopped (остановлен), running (выполняется) или suspended (приостановлен). В конце строки указывается команда, которая исполняется данным процессом. Один из номеров выполняющихся заданий помечен знаком +, а еще один — знаком -. Процесс, помеченный знаком +, будет по умолчанию считаться аргументом команд fg или bg, если они вызываются без параметров. Процесс, помеченный знаком -, получит знак +, если только завершится по какой-либо причине процесс, который был помечен знаком +.
А теперь можно рассказать и о командах fg и bg, которые служат для перевода процессов на передний план или возврата их в фоновый режим. В качестве аргумента обеим этим командам передаются номера тех заданий, которые присутствуют в выводе команды jobs. Если аргументы отсутствуют, то подразумевается задание, помеченное знаком +. Команда fg переводит указанный в аргументе процесс на передний план, а команда bg — переводит процесс в фоновый режим. Одной командой bg можно перевести в фоновый режим сразу несколько процессов, а вот возвращать их на передний план необходимо по одному.
Команда nohup
Предположим, вы запустили из оболочки bash несколько процессов, часть из них в фоновом режиме. И по каким-то причинам завершили текущую сессию работы в оболочке. При завершении сессии оболочка посылает всем порожденным ею процессам сигнал "отбой", по которому некоторые из порожденных ею процессов могут завершиться, что не всегда желательно. Если вы хотите запустить в фоновом режиме программу, которая должна выполняться и после вашего выхода из оболочки, то ее нужно запускать с помощью утилиты nohup. Делается это так:
nohup команда &
Запускаемый таким образом процесс будет игнорировать посылаемые ему сигналы (если это возможно, см. табл. 8.1). Стандартный выходной поток и стандартный поток ошибок при таком запуске команд перенаправляются в файл nohup.out или $HOME/nohup.out.
Команда nohup имеет побочный эффект, заключающийся в том, что значение nice для запускаемого процесса увеличивается на 5, т. е. процесс выполняется с более низким приоритетом.


Parent, child, fork - процессы


Понятие процесса играет ключевую роль в современных ОС. Существует много определений процессов, я воспользуюсь простым определением – процесс, это выполняющийся экземпляр программы. Хотя это определение, в общем, «работает», оно не совсем подходит к многопоточным программам Linux, о которых мы поговорим в следующей статье. Важный аспект процессов с точки зрения ОС – неделимость процесса относительно выделения ресурсов. Система выделяет ресурсы процессу в целом, а не его частям. Внутри процесса задача управления ресурсами ложится на программиста. Для каждого процесса ядро системы поддерживает специальную структуру данных task_struct, в которой хранятся важнейшие параметры процесса (процессы уровня пользователя не имеют доступа к этой структуре). В структуре task_struct есть специальное поле, в котором хранится численный идентификатор процесса (Process Identifier, PID). Именно этот идентификатор используется для обозначения процессов на уровне прикладного API Linux. 

Если вы хотите запустить из вашей программы экземпляр другой программы, вы должны пожертвовать для этого уже существующим процессом. Если вы хотите, чтобы новая программа работала одновременно со старой, нужно сначала раздвоить процесс с помощью fork(), а затем заместить образ программы в одной из копий образом новой программы. Для замены образа одной программы образом другой применяются функции семейства exec*. Функций этого семейства всего шесть: execl(), execlp(), execle(), execv(), execvp() и execv(). Если вы присмотритесь к названиям функций, то увидите, что первые три имеют имена вида execl*, а вторые три – имена вида execv*. Эти функции отличаются списком параметров, а также тем, как обрабатывается имя файла. 

fork        
                        
В Unix-системах, fork() — системный вызов, создающий новый процесс (потомок), который является практически полной копией процесса-родителя, выполняющего этот вызов. Между процессом-потомком и процессом-родителем существуют различия:
PID процесса-потомка отличен от PID процесса-родителя;
значению PPID процесса-потомка присваивается значение PID процесса-родителя;
Процесс-потомок получает собственную таблицу файловых дескрипторов, являющуюся копией таблицы процесса-родителя на момент вызова fork(). Это означает, что открытые файлы наследуются, но если процесс-потомок, например, закроет какой-либо файл, то это не повлияет на таблицу дескрипторов процесса-родителя.
для процесса-потомка очищаются все ожидающие доставки сигналы;
временная статистика выполнения процесса-потомка в таблицах ОС обнуляется;
блокировки памяти и записи, установленные в процессе-родителе, не наследуются.
После вызова fork() алгоритм обычно разветвляется (в случае успешного выполнения функции fork(), она возвращает PID процесса-потомка родительскому процессу и нуль — 
Fork-бомба                        

fork-бомба порождает большое количество собственных копий и тем самым пытается заполнить свободное место в списке активных процессов операционной системы. После заполнения списка процессов становится невозможным старт полезной программы. Даже если какой-либо другой процесс прекратит работу и место в списке процессов освободится, то старт полезной программы маловероятен, так как множество других копий fork-бомбы уже ждут возможности запустить свою очередную копию.
Кроме заполнения списка процессов, возможны также стратегии заполнения виртуальной памяти, процессорного времени, сокетов и других системных ресурсов. Результатом исчерпания этих ресурсов становится замедление работы или практически остановка операционной системы и/или полезных программ (зависание компьютера).
Fork-бомба может быть получена и в результате ошибки при добросовестном программировании. Например, программа, слушающая сетевой порт, может при получении сетевого пакета или установлении соединения «упасть» в бесконечный цикл создания своих копий для обработки пакета или соединения. Простая ошибка программирования может привести к утечке памяти или к последствиям, характерным для результатов работы fork-бомбы.

процессу-потомку. Если порождение процесса-потомка закончилось неудачей, функция fork() возвращает значение −1).
После fork() процесс-потомок чаще всего выполняет системный вызов exec(), загружающий в пространство процесса новую программу (именно так, и только так, в Unix-системе выполняется запуск программы в отдельном процессе). Так, первый (нулевой) процесс Unix (ядро системы) создаёт свою копию, чтобы запустить init (процесс с PID = 1), который в свою очередь создаёт дочерние процессы для запуска инициализации системы и терминалов.
Некоторые программы создают дочерние процессы не для запуска другой программы, а для выполнения параллельной задачи. Так, например, поступают простые сетевые серверы — при подсоединении клиента, сервер создаёт свою копию (дочерний процесс), которая обслуживает клиентское соединение и завершается по его закрытии. Родительский же процесс продолжает ожидать новых соединений.
Вызов fork() выполняется довольно долго, так как требует копирования большого количества данных. Для того чтобы это обойти, некоторые сетевые серверы (например, веб-серверы Apache и Lighttpd), создают дочерние процессы заранее, чтобы уменьшить время отклика сервера. Также существуют «облегченные» реализации fork() (Например в ядре Linux[1]), отображающие в новый процесс страницы памяти родительского, вместо того чтобы их копировать (новая страница создаётся только при изменении её содержимого одним из процессов), что существенно снижает время создания нового процесса (т. н. copy-on-write).
Процесс-сирота                        
Процесс-сирота (англ. orphan process) — в семействе операционных систем UNIX вспомогательный процесс, чей основной процесс (или связь с ним) был завершен нештатно (не подав сигнала на завершение работы).
Обычно, «сиротой» остается дочерний процесс после неожиданного завершения родительского, но возможно возникновение сервера-сироты (локального или сетевого) при неожиданном прерывании связи или завершении клиентского процесса.
Процессы-сироты расходуют системные ресурсы сервера и могут быть источником проблем. Существует несколько их решений:
Уничтожение (англ. extermination) — заключается в завершении процесса (например, посылкой сигнала SIGTERM или SIGKILL), используется наиболее часто (особенно оператором обслуживающим систему)
Перевоплощение (англ. reincarnation) — система пытается «воскресить» родителей в состоянии на момент перед их удалением или найти других (например, более старших) родителей.
Выдача лимита времени (англ. expiration) — процессу выдаётся временная квота для завершения до момента, когда он будет «убит» принудительно. Отметим, что процессу оставлена возможность запросить дополнительное время для завершения.
В Unix-подобных системах все процессы-сироты немедленно усыновляются специальным системным процессом «init». Эта операция ещё называется переподчинением (англ. reparenting) и происходит автоматически. Хотя технически процесс «init» признаётся родителем этого процесса, его всё равно считают «осиротевшим», поскольку первоначально создавший его процесс более не существует.


Процесс-зомби        
                             
Проце́сс-зо́мби, зо́мби (англ. zombie process, англ. defunct process) — дочерний процесс в Unix-системе, завершивший своё выполнение, но ещё присутствующий в списке процессов операционной системы, чтобы дать родительскому процессу считать код завершения.

Возникновение зомби
Процесс при завершении освобождает все свои ресурсы (за исключением PID — идентификатора процесса) и становится «зомби» — пустой записью в таблице процессов, хранящей код завершения для родительского процесса.
Система уведомляет родительский процесс о завершении дочернего с помощью сигнала SIGCHLD. Предполагается, что после получения SIGCHLD он считает код возврата с помощью системного вызова wait(), после чего запись зомби будет удалена из списка процессов.
Если родительский процесс игнорирует SIGCHLD (а он игнорируется по умолчанию), то зомби остаются до завершения родительского процесса.

Проблемы зомби
Игнорирование SIGCHLD в принципе не является правильным, но может быть приемлемо для короткоживущих программ (некоторые программы могут делать это намеренно, например, для исключения повторения PID). Но для долгоживущих и часто создающих дочерние процессы программ это неприемлемо, потому что накапливание зомби приводит к «утечке ресурсов» (то есть к их постепенному блокированию).
Зомби не занимают памяти (как процессы-сироты), но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.
При достижении лимита пользователь, от имени которого выполняется программа, и все его программы не будут способны создавать новые дочерние процессы. Кроме всего прочего, пользователь, от имени которого выполняется родительский процесс, не сможет зайти на консоль (локальную или удалённую) или выполнить какие-либо команды на уже открытой консоли (потому что для этого командный интерпретатор sh должен создать новый процесс), и для восстановления работоспособности (завершения виновной программы) будет необходимо вмешательство системного администратора.
Если же процесс выполнялся от имени суперпользователя, то проблему может решить только перезагрузка (причём зачастую — только аппаратным рестартом). Некоторые операционные системы (например, Sun Solaris) при возникновении такой ситуации аварийно завершают часть выполняющихся процессов, восстанавливая работоспособность системы.
