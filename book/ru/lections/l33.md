# Тема: Ядро ОС Linux. Порядок и уровни загрузки ОС Linux. Вторичный загрузчик Grub. Мультерминальная ОС (TTY/VTY). Разграничение прав пользователей в ОС Linux. 

Ядро ОС Linux
Ядро Linux — ядро операционной системы, соответствующее стандартам POSIX, составляющее основу операционных систем семейства Linux. Разработка кода ядра была начата финским студентом Линусом Торвальдсом в 1991 году, на его имя зарегистрирована Торговая марка «Linux».
Код написан в основном на Си с некоторыми расширениями gcc и на ассемблере (с использованием AT&T-синтаксиса GNU Assembler).
Распространяется как свободное программное обеспечение на условиях GNU General Public License, кроме несвободных элементов, особенно драйверов, которые используют прошивки, распространяемые под различными лицензиями.

Живет ядро по адресу: https://www.kernel.org, последняя версия на 10.2017 - 4.13

Версии ядра

Ядро Linux поддерживает многозадачность, виртуальную память, динамические библиотеки, отложенную загрузку, производительную систему управления памятью и многие сетевые протоколы.
На сегодняшний день Linux — монолитное ядро с поддержкой загружаемых модулей. Драйверы устройств и расширения ядра обычно запускаются в 0-м кольце защиты, с полным доступом к оборудованию. В отличие от обычных монолитных ядер, драйверы устройств легко собираются в виде модулей и загружаются или выгружаются во время работы системы.

Архитектура ядра


На верхнем уровне находится пользовательское пространство (пространство приложений). Здесь исполняются приложения пользователя. Под пользовательским пространством располагается пространство ядра. Здесь функционирует ядро Linux.

Имеется также библиотека GNU C (glibc). Она предоставляет интерфейс системных вызовов, который обеспечивает связь с ядром и дает механизм для перехода от приложения, работающего в пространстве пользователя, к ядру. Это важно, поскольку ядро и пользовательское приложение располагаются в разных защищенных адресных пространствах. При этом, в то время как каждый процесс в пространстве пользователя имеет свое собственное виртуальное адресное пространство, ядро занимает одно общее адресное пространство. 
Ядро Linux можно, в свою очередь, разделить на три больших уровня. Наверху располагается интерфейс системных вызовов, который реализует базовые функции, например, чтение и запись. Ниже интерфейса системных вызовов располагается код ядра, точнее говоря, архитектурно-независимый код ядра. Этот код является общим для всех процессорных архитектур, поддерживаемых Linux. Еще ниже располагается архитектурно-зависимый код, образующий т.н. BSP (Board Support Package - пакет поддержки аппаратной платформы). Этот код зависит от процессора и платформы для конкретной архитектуры.
Подсистемы ядра Linux

Интерфейс системных вызовов
SCI - это тонкий уровень, предоставляющий средства для вызова функций ядра из пространства пользователя. Как уже говорилось, этот интерфейс может быть архитектурно зависимым, даже в пределах одного процессорного семейства. SCI фактически представляет собой службу мультиплексирования и демультиплексирования вызова функций. Реализация SCI находится в ./linux/kernel, а архитектурно-зависимая часть - в ./linux/arch. 

Управление процессами
Управление процессами сконцентрировано на исполнении процессов. В ядре эти процессы называются потоками (threads); они соответствуют отдельным виртуализованным объектам процессора (код потока, данные, стек, процессорные регистры). В пространстве пользователя обычно используется термин процесс, хотя в реализации Linux эти две концепции (процессы и потоки) не различают. Ядро предоставляет интерфейс программирования приложений (API) через SCI для создания нового процесса (порождения копии, запуска на исполнение, вызова функций Portable Operating System Interface [POSIX]), остановки процесса (kill, exit), взаимодействия и синхронизации между процессами (сигналы или механизмы POSIX).
Еще одна задача управления процессами - совместное использование процессора активными потоками. В ядре реализован алгоритм планировщика, время работы которого не зависит от числа потоков, претендующих на ресурсы процессора. Название этого планировщика - O(1) - подчеркивает, что на диспетчеризацию одного потока затрачивается столько же времени, как и на множество потоков. Планировщик O(1) также поддерживает симметричные многопроцессорные конфигурации (SMP). Исходные коды системы управления процессами находятся в ./linux/kernel, а коды архитектурно-зависимой части - в ./linux/arch).
Управление памятью
Другой важный ресурс, которым управляет ядро - это память. Для повышения эффективности, учитывая механизм работы аппаратных средств с виртуальной памятью, память организуется в виде т.н. страниц (в большинстве архитектур размером 4 КБ). В Linux имеются средства для управления имеющейся памятью, а также аппаратными механизмами для установления соответствия между физической и виртуальной памятью.
Однако управление памятью - это значительно больше, чем просто управление буферами по 4 КБ. Linux предоставляет абстракции над этими 4 КБ буферами, например, механизм распределения slab allocator. Этот механизм управления базируется на 4 КБ буферах, но затем размещает структуры внутри них, следя за тем, какие страницы полны, какие частично заполнены и какие пусты. Это позволяет динамически расширять и сокращать схему в зависимости от потребностей вышележащей системы.
В условиях наличия большого числа пользователей памяти возможны ситуации, когда вся имеющаяся память будет исчерпана. В связи с этим страницы можно удалять из памяти и переносить на диск. Этот процесс обмена страниц между оперативной памятью и жестким диском называется подкачкой. Исходные коды управления памятью находятся в ./linux/mm.
Виртуальная файловая система
Еще один интересный аспект ядра Linux - виртуальная файловая система (VFS), которая предоставляет общую абстракцию интерфейса к файловым системам. VFS предоставляет уровень коммутации между SCI и файловыми системами, поддерживаемыми ядром


На верхнем уровне VFS располагается единая API-абстракция таких функций, как открытие, закрытие, чтение и запись файлов. На нижнем уровне VFS находятся абстракции файловых систем, которые определяют, как реализуются функции верхнего уровня. Они представляют собой подключаемые модули для конкретных файловых систем (которых существует более 50). Исходные коды файловых систем находятся в ./linux/fs.
Ниже уровня файловой системы находится кэш буферов, предоставляющий общий набор функций к уровню файловой системы (независимый от конкретной файловой системы). Этот уровень кэширования оптимизирует доступ к физическим устройствам за счет краткосрочного хранения данных (или упреждающего чтения, обеспечивающего готовность данных к тому моменту, когда они понадобятся). Ниже кэша буферов находятся драйверы устройств, реализующие интерфейсы для конкретных физических устройств.
Сетевой стек
Сетевой стек по своей конструкции имеет многоуровневую архитектуру, повторяющую структуру самих протоколов. Вы помните, что протокол Internet Protocol (IP) - это базовый протокол сетевого уровня, располагающийся ниже транспортного протокола Transmission Control Protocol, TCP). Выше TCP находится уровень сокетов, вызываемый через SCI.
Уровень сокетов представляет собой стандартный API к сетевой подсистеме. Он предоставляет пользовательский интерфейс к различным сетевым протоколам. Уровень сокетов реализует стандартизованный способ управления соединениями и передачи данных между конечными точками, от доступа к "чистым" кадрам данных и блокам данных протокола IP (PDU) и до протоколов TCP и User Datagram Protocol (UDP). Исходные коды сетевой подсистемы ядра находятся в каталоге ./linux/net.
Драйверы устройств
Подавляющее большинство исходного кода ядра Linux приходится на драйверы устройств, обеспечивающие возможность работы с конкретными аппаратными устройствами. В дереве исходных кодов Linux имеется подкаталог драйверов, в котором, в свою очередь, имеются подкаталоги для различных типов поддерживаемых устройств, таких как Bluetooth, I2C, последовательные порты и т.д. Исходные коды драйверов устройств находятся в ./linux/drivers.
Архитектурно-зависимый код
Хотя основная часть Linux независима от архитектуры, на которой работает операционная система, в некоторых элементах для обеспечения нормальной работы и повышения эффективности необходимо учитывать архитектуру. В подкаталоге ./linux/arch находится архитектурно-зависимая часть исходного кода ядра, разделенная на ряд подкаталогов, соответствующих конкретным архитектурам. Все эти каталоги в совокупности образуют BSP. В случае обычного настольного ПК используется каталог i386. Подкаталог для каждой архитектуры содержит ряд вложенных подкаталогов, относящихся к конкретным аспектам ядра, таким как загрузка, ядро, управление памятью и т.д. Исходные коды архитектурно-зависимой части находятся в ./linux/arch.
Порядок  и уровни загрузки ОС Linux
При загрузке компьютера происходит последовательная передача управления от системной прошивки компьютера (BIOS или UEFI) к загрузчику, а от него — к ядру. Затем ядро запускает планировщик (для реализации многозадачности) и выполняет программу init (которая настраивает пользовательское окружение и позволяет осуществлять взаимодействие с пользователем и вход в систему), после чего ядро переходит в состояние бездействия до тех пор, пока не получит внешний вызов.


Основные этапы загрузки:
Системная прошивка компьютера выполняет первичную проверку и инициализацию аппаратного обеспечения.


В случае BIOS прошивка загружает в оперативную память и выполняет загрузочный код с одного из разделов заданного загрузочного устройства, который содержит фазу 1 загрузчика Linux. Фаза 1 загружает фазу 2 (значительный по размеру код загрузчика). 
В случае UEFI запускается загрузчик загруженный со служебного раздела (EFS), который выбирается согласно настройкам приоритета загрузки определенного в энергонезависимой памяти компьютера. При этом возможна загрузка не только специализированного загрузчика, но можно загрузить и непосредственно ядро Linux (для этого ядро должно быть собрано с опцией EFI_STUB).
Загрузчик зачастую предлагает пользователю меню с доступными вариантами загрузки. После выбора или после заданного тайм-аута загрузчик загружает ядро.
Загруженное ядро распаковывается в памяти, настраивает системные функции, такие как работа необходимого оборудования и управление страницами памяти, после чего делает вызов start_kernel().
После этого start_kernel() выполняет основную настройку системы (прерывания, остальные функции управления памятью, инициализацию устройств, драйверов и т. д.), а потом порождает процесс бездействия, диспетчер и отдельно от них — процесс init (выполняющийся в пользовательском пространстве).
Планировщик начинает более эффективно управлять системой, в то время как ядро переходит к бездействию.
Процесс init выполняет необходимые сценарии, которые настраивают все службы и структуры, не относящиеся к уровню ядра, в результате чего будет создано пользовательское окружение, и пользователю будет предоставлен экран входа в систему.

Когда происходит завершение работы, init вызывается для управляемого закрытия программ пользовательского уровня, тоже согласно сценариям. После этого init закрывается, а ядро производит своё собственное завершение работы.

Уровни загрузки
0    Halt the system. - Выключить систему
1    Single-user mode (for special administration). - Rescue - Режим восстановления
2    Local Multiuser with Networking but without network service (like NFS)
3    Full Multiuser with Networking             
4    Not Used
5    Full Multiuser with Networking and X Windows(GUI)
6    Reboot.
Мультерминальная ОС (TTY/VTY)

Читать: https://habrahabr.ru/company/neobit/blog/330764/


Разграничение прав пользователей в ОС Linux. 


Пользователи и группы

Несколько слов о том, зачем вообще возникла необходимость в механизме прав доступа. Все дело в том, что операционная система Linux с самого начала разрабатывалась как многопользовательская система, в которой работает не один, а несколько пользователей. Для того, чтобы была возможность разграничить полномочия пользователей, работающих в системе, в ней и предусмотрен упомянутый механизм.

Правильная настройка прав доступа позволяет повысить надёжность системы, защитив от изменения или удаления важные системные файлы. Наконец, поскольку внешние устройства с точки зрения Linux также являются объектами файловой системы, механизм прав доступа можно применять и для управления доступом к устройствам.

С помощью прав доступа отдельные пользователи могут иметь свои "личные" файлы и каталоги. К примеру, если пользователь kevin создал в своём домашнем каталоге файлы (каталог /home/kevin/..), то он является владельцем этих файлов и может определить права доступа к ним для себя и остальных пользователей. Он может, например, полностью закрыть доступ к своим файлам для остальных пользователей или групп пользователей, или разрешить им читать свои файлы (read), запретив изменять (write) и исполнять их (ute).Однако в большинстве случаев другим пользователям разрешается по умолчанию читать ваши файлы, но не изменять и не удалять их.

У любого файла в *nix-подобных системах (к каковой Linux также относиться) есть владелец - один из пользователей. Помимо этого, каждый файл одновременно принадлежит и некоторой группе пользователей системы. Каждый пользователь имеет возможность входить в любое количество групп, и в каждую группу может входить любое количество пользователей из числа определённых в системе.

Также помимо учётных записей, которые используют люди для работы с системой, в Linux предусмотрены учётные записи для т. н. системных пользователей: с точки зрения системы это такие же пользователи, которые могут быть владельцами файлов, однако эти учётные записи используются только для работы некоторых программ-серверов. Например, стандартный системный пользователь mail используется программами доставки почты.

При создании в системе новой учетной записи (иными словами нового пользователя), он добавляется по крайней мере в одну группу. Как правило, группы нужны для совместного доступа нескольких пользователей к определённым ресурсам. Например, на сервере организации для каждого проекта может быть создана отдельная группа, в которую войдут учётные записи (имена пользователей) сотрудников, работающих над этим проектом.

При этом файлы, относящиеся к проекту, могут принадлежать этой группе и быть доступными для её членов. В системе также определено несколько групп (например, bin), которые используются для управления доступом системных программ к различным ресурсам. Как правило, членами этих групп являются системные пользователи (администраторы), простые пользователи не включаются в такие группы.

Виды прав доступа

Теперь рассмотрим, какие бывают права доступа. Они определяются по отношению к трём типам действий: чтение, запись и исполнение. Эти права доступа могут быть предоставлены трём классам пользователей: владельцу файла (пользователю), группе, которой принадлежит файл, а также всем остальным пользователям, не входящим в эту группу. Разделение на права подразумевает совершение строго определенных действий над файлами и директориями. Так, право на чтение даёт пользователю возможность читать содержимое файла или, если такой доступ разрешён к каталогам, просматривать содержимое каталога (используя команду ls).

Право на запись даёт пользователю возможность записывать или изменять файл, а право на запись для каталога — возможность создавать новые файлы или удалять файлы из этого каталога. Наконец, право на исполнение позволяет пользователю запускать файл как программу или сценарий командной оболочки (разумеется, это действие имеет смысл лишь в том случае, если файл является программой или сценарием). Владение правами на исполнение для каталога позволяет перейти (командой cd) в этот каталог.

Чтобы получить информацию о правах доступа, необходимо воспользоваться командой ls с ключом -l. В результате будет выведена подробная информация о файлах и каталогах, в которой будут, среди прочего, отражены и права доступа. Рассмотрим следующий пример:

/home/kevin/books# ls -l nochnoj_dozor
-rw-rr 1 kevin users 505 May 10 12:10 nochnoj_dozor

Во второй строке приведен результат выполнения команды /home/kevin/books# ls -l nochnoj_dozor. Первое поле в этой строке (-rw-rr) отражает права доступа к файлу. Третье поле указывает на владельца файла (kevin), четвёртое поле указывает на группу, которая владеет этим файлом (users). Последнее поле — это имя файла (nochnoj_dozor). Другие поля описаны в документации к команде ls.

А теперь более подробно. Данный файл является собственностью пользователя kevin и группы users. Последовательность -rw-rr показывает права доступа для пользователя — владельца файла, пользователей — членов группы-владельца, а также для всех остальных пользователей.

Первый символ из этого ряда (-) обозначает тип файла. Символ "-" означает, что это - обычный файл, а не каталог (в этом случае первым символом было бы d) или псевдофайл устройства. Следующие три символа (rw-) представляют собой права доступа, предоставленные владельцу kevin. Символ r - сокращение от read (англ. читать), а w — сокращение от write (англ. писать). Таким образом, kevin имеет право на чтение и запись (модификацию) файла nochnoj_dozor.

После символа w может стоять символ x, который означает наличие прав на исполнение (англ. ute, исполнять) файла. Однако символ "-", стоящий здесь вместо x, указывает, что kevin не имеет права на исполнение этого файла. Это разумно, так как файл nochnoj_dozor не является программой (в данном случае это текстовый файл). В то же время, пользователь, зарегистрировавшийся в системе как kevin, при желании может предоставить себе право на исполнение данного файла, поскольку является его владельцем. Для изменения прав доступа к файлу или каталогу используется команда chmod.

Следующие три символа (r) отражают права доступа группы к файлу. Группой-собственником файла в нашем примере является группа users. Поскольку здесь присутствует только символ r, все пользователи из группы users могут читать этот файл, но не могут изменять или исполнять его.

Наконец, последние три символа (это опять r) информируют нам о правах, которые есть на доступ к этому файлу всех других пользователей, помимо собственника файла и пользователей из группы users. Так как здесь указан только символ r, эти пользователи тоже могут читать файл.

Вот ещё несколько примеров:

-rwxr-xx

Пользователь-владелец файла может читать файл, изменять и исполнять его; пользователи, члены группы-владельца могут читать и исполнять файл, но не изменять его; все остальные пользователи могут лишь запускать файл на выполнение.

-rw-

Только владелец файла может читать и изменять его.

-rwxrwxrwx

Все пользователи могут читать файл, изменять его и запускать на выполнение.

Никто, включая самого владельца файла, не имеет прав на его чтение, запись или выполнение. Строго говоря, за исключением лишь суперпользователя (root), который может выполнять любые операции над любыми файлами в системе. Хотя такая ситуация вряд ли имеет практический смысл, с точки зрения системы она является вполне корректной. Разумеется, владелец файла может в любой момент изменить права доступа к нему.

Далее хочу сделать важное замечание. Дело в том, что возможность доступа к файлу зависит также и от прав доступа к каталогу, в котором находится файл. Например, даже если права доступа к файлу установлены как -rwxrwxrwx, другие пользователи не могут получить доступ к файлу, пока они не имеют прав на исполнение для каталога, в котором находится файл. Другими словами, чтобы воспользоваться имеющимися у вас правами доступа к файлу, вы должны иметь право на исполнение для всех каталогов вдоль пути к файлу.

Чем дальше, тем интереснее :) В операционной системе Linux "пользователями", которые выполняют различные действия с файлами и каталогами, являются на самом деле вовсе не люди, а программы, выполняемые в системе — процессы. Ярким примером может быть та же командная оболочка, которая считывает команды пользователя из командной строки и передаёт их системе на выполнение. Архитектура системы такова, что каждая ее программа (процесс) выполняется от имени определённого пользователя. Её возможности работы с файлами и каталогами определяются исходя из прав доступа, определёнными для этого пользователя.

Права доступа и администрирование системы

Особо отмечу, что установка и поддержание оптимальных прав доступа является одной из важнейших задач системного администратора. Права должны быть достаточными для нормальной работы пользователей и программ, но не большими, чем необходимо для такой работы. При установке прав доступа необходимо придерживаться принципа "запрещено все, что не разрешено".

Поскольку программы, исполняемые от имени суперпользователя (root), могут совершать любые действия с любыми файлами и каталогами, их выполнение может нанести системе серьёзный ущерб. Это может быть как следствием уязвимостей или ошибок в программах, так и результатом ошибочных действий самого пользователя. Поэтому работа с правами суперпользователя требует особой осторожности и советую не раздавать их "налево-направо".

Основные команды

chmod

изменение прав доступа к файлу или каталогу.

Синтаксис команды chmod:

chmod {a,u,g,o}{+,-}{r,w,x} filenames

Сначала после имени команды вы ставите один или несколько из следующих символов: a (сокращение от "all" все), u (сокращение от "user" пользователь), g (сокращение от "group" группа), или o (сокращение от "other" прочие). Затем вы точно определяете, добавляете ли вы права (+) или убираете (-). Наконец, вы пишете один или несколько символов из следующего набора: r ("read" чтение), w ("write" запись), x ("ute" исполнение).

А вот пример работы с командой chmod в консоли:

chown

изменение владельца файла.

chgroup

изменение группы, которой принадлежит файл.

umask

определение прав доступа по умолчанию для файлов, создаваемых пользователем.

Если у кого-нибудь возникнет необходимость в использовании последних трех команд, то оперативно получить по ним справку поможет команда man (сокращение от "manual"). Формат ее вызова простой:

/home/kevin# man ls

и на экран будет выведена экранная документация для команды ls.

На этом спешу раскланяться и пожелать успехов в освоении одновременно непростой и интересной системы, какой на данный момент является Linux.




Модели управления доступом
    Модели управления доступом
    Дискреционное управление доступом
    Мандатное управление доступом
    Метки критичности
    Ролевое управление доступом
    Ядро RBAC
    Иерархический RBAC



Модели управления доступом

Модель управления доступом – это структура, которая определяет порядок доступа субъектов к объектам. Для реализации правил и целей этой модели используются технологии управления доступом и механизмы безопасности. Существует три основных модели управления доступом: дискреционная, мандатная и недискреционная (также называемая ролевой). Каждая модель использует различные методы для управления доступом субъектов к объектам, каждая имеет свои преимущества и ограничения. Выбор оптимальной модели управления доступом следует производить на основе целей бизнеса и целей безопасности компании, а также на основе ее культуры и стиля управления бизнесом. Некоторые компании используют только одну модель, другие комбинируют их для получения необходимого уровня защиты.

Эти модели встроены в ядро различных операционных систем и во многих случаях поддерживаются приложениями. Каждая операционная система имеет ядро безопасности, которое реализует концепцию монитора обращений (reference monitor), которая зависит от встроенной в систему модели управления доступом. Для каждой попытки доступа, перед тем, как субъект сможет начать взаимодействовать с объектом, ядро безопасности проверяет правила модели управления доступом, чтобы определить, является ли запрос допустимым. В следующих разделах будет рассказано про эти различные модели доступа, поддерживающие их технологии и о том, когда их следует применять.

Дискреционное управление доступом

Если пользователь создает файл, он является владельцем этого файла. Идентификатор этого пользователя размещается в заголовке файла. Владение может быть также предоставлено определенному человеку. Система, которая использует дискреционное (избирательное) управление доступом (DAC – Discretionary Access Control) позволяет владельцу ресурса определять, какие субъекты могут использовать этот ресурс. Эта модель называется дискреционной (избирательной), т.к. управление доступом основано на решениях владельца. Часто руководители подразделений являются владельцами данных в рамках своих подразделений. Будучи владельцами, они могут решать, кому следует, а кому не следует иметь доступ к этим данным.

В модели DAC ограничения доступа основываются на авторизации пользователя. Это означает, что владельцы могут определять, какой тип доступа может быть разрешен к их объектам. Если компания использует модель DAC, сетевой администратор может разрешить владельцам ресурсов управлять доступом пользователей к своим ресурсам. Чаще всего модель DAC реализуется посредством списков контроля доступа (ACL), содержимое которых определено владельцами. Работа ACL реализуются средствами операционной системы. Это может позволить пользователям использовать информацию динамически вместо более статичного мандатного или ролевого управления доступом. Большинство операционных систем основаны на модели DAC (например, системы Windows, Linux, Macintosh и большинство систем *nix).

DAC может быть применен как к древовидной структуре директорий, так и к файлам, которые в них содержатся. Мир персональных компьютеров использует такие разрешения доступа, как «Нет доступа» (No Access), «Чтение» (Read), «Запись» (Write), «Выполнение» (Execute), «Удаление» (Delete), «Изменение» (Change), «Полный доступ» (Full Control). К примеру, атрибут «Чтение» позволяет читать файл, но не вносить в него изменения; атрибут «Изменение» позволяет читать, записывать, выполнять и удалять файл, но не менять его ACL или владельца файла; атрибут «Полный доступ» позволяет производить любые действия с файлом, разрешениями на доступ к нему и владением им.

Посредством дискреционной модели, например, Сэм может предоставить совместный доступ к диску D на своем компьютере Дэвиду, а Дэвид может скопировать с него все MP3 Сэма. При этом Сэм может заблокировать доступ к своему диску D для своего начальника, чтобы тот не знал, что Сэм тратит время и ресурсы на скачивание музыки и ее раздачу своим друзьям.

    Управление доступом на основе идентификатора. Системы DAC предоставляют, либо отказывают в доступе на основе идентификации субъекта. Идентификация может быть как на уровне пользователя, так и на уровне его членства в группе. Так, например, владелец данных может предоставить доступ к своему файлу Бобу (идентификатор пользователя) и группе «Бухгалтерия» (идентификатор группы).

 Мандатное управление доступом

В модели мандатного управления доступом (MAC – Mandatory Access Control) пользователи и владельцы данных не могут самостоятельно определять, кто может иметь доступ к файлам. Окончательное решение принимает операционная система, и это решение может не совпадать с желаниями пользователя. Эта модель является более структурированной и жесткой, она основана на системе меток безопасности (security label). Пользователи получают уровни допуска (секретно, совершенно секретно, конфиденциально и т.д.), таким же способом классифицируются данные. Допуски и классы данных сохраняются в метках безопасности и являются границами для субъектов и объектов. Когда система принимает решение в процессе выполнения запроса на доступ к объекту, она основывается на уровне допуска субъекта, классификации объекта и политике безопасности системы. Правила доступа субъектов к объектам разрабатываются офицером безопасности, настраиваются администратором, реализуются операционной системой и поддерживаются технологиями безопасности.

Метки безопасности прикрепляются ко всем объектам, каждый файл, директория, устройство имеют свою метку безопасности, содержащую информацию о классе их информации. Например, если пользователь имеет уровень допуска «Секретно», а запрашивает информацию класса «Совершенно секретно», он получит отказ, поскольку его допуск не равен (и не выше) классификации.

    ПРИМЕЧАНИЕ. Термины «метка безопасности» (security label), «метка критичности» и «метка чувствительности» (sensitivity labels) являются взаимозаменяемыми.

Каждый субъект и объект всегда должен иметь связанную с ним метку с атрибутами, поскольку это является частью критериев принятия решения операционной системой.

Эта модель применяется в среде, в которой классификация информации и конфиденциальность чрезвычайно важны, например, в военных организациях. На базе этой модели разработаны специализированные версии Unix-систем, например, SE Linux, Trusted Solaris. Компании не могут просто переключаться между использованием DAC и MAC. Им потребуется специально приобрести для этого операционную систему, спроектированную и реализующую правила MAC. Системы DAC не понимают меток безопасности, классификации, уровней допуска и поэтому не могут применяться в организациях, которым нужна такая структура управления доступом.


Метки критичности

Когда используется модель MAC, каждый субъект и объект должен иметь метку критичности, также называемую меткой безопасности. Эта метка указывает на классификацию и различные категории. Классификация указывает на уровень критичности, а с помощью категорий реализуется принцип «необходимо знать» (need-to-know). Метка критичности показана на рисунке 2-10. Если кто-то имеет допуск к «совершенно секретной» информации, это вовсе не означает, что ему «необходимо знать» всю информацию с грифом «совершенно секретно».
Рисунок 2-10.Метка критичности состоит из классификации и категорий
Классификация использует иерархическую структуру, в которой один уровень является более доверенным, чем другой. Категории не используют иерархическую структуру, они представляют собой отдельные виды информации в рамках системы. Категории могут соответствовать структуре подразделений компании, проектам или уровням должностей. Классификация проводится по степени конфиденциальности информации, она зависит от среды, в которой работает компания.

    ПРИМЕЧАНИЕ. В реализациях MAC, система принимает решение о возможности доступа, сравнивая уровень допуска субъекта и уровень «необходимо знать» с меткой безопасности. В DAC система сравнивает идентификатор субъекта со списком ACL ресурса.

Программные и аппаратные охранные средства (guard) позволяют обмениваться данными между доверенными (высокий уровень гарантий) и менее доверенными (низкий уровень гарантий) системами и средами, выполняя функции посредника между ними. Например, вы работаете на системе MAC (работающей в выделенной модели безопасности на уровне «Секретно») и вам нужно взаимодействовать с базой данных MAC (работающей в многоуровневом режиме безопасности, достигающем уровня «Совершенно секретно»). Эти две системы могут обеспечивать различные уровни защиты, и, если менее доверенная система будет напрямую взаимодействовать с более доверенной, в системе безопасности появятся уязвимости и повысятся риски компрометации. Программные охранные средства позволяют взаимодействовать системам, работающим на разных уровнях безопасности. Различные их виды могут применяться для выполнения фильтрации, обработки запросов, блокировки и обезличивания данных. Также существуют аппаратные охранные средства, представляющие собой устройства с двумя сетевыми картами, подключенными к двум разным системам, которым нужно взаимодействовать между собой. Охранные средства могут использоваться для соединения различных систем MAC или сетей, работающих в разных режимах безопасности и на разных уровнях безопасности. В большинстве случаев, менее доверенные системы могут отправлять сообщения более доверенным системам, но в обратном направлении они могут принимать только подтверждения о доставке.

Ролевое управление доступом

Модель ролевого управления доступом (RBAC – Role-based Access Control), также называемая недискреционным управлением доступом (Nondiscretionary Access Control), использует централизованно администрируемый набор контролей, предназначенных для определения порядка взаимодействия субъекта с объектом. Этот тип модели разрешает доступ к ресурсам, основываясь на роли пользователя в компании. Это называют недискреционным подходом, поскольку назначение пользователю роли является неизбежным. Это означает, что если вам в компании назначена роль «Подрядчик», вы ничего с этим сделать не можете. Вы не определяете самостоятельно, какая роль вам будет назначена.

Более традиционное администрирование прав доступа основано на модели DAC, в которой управление доступом происходит на уровне объекта с использованием ACL. Этот подход более сложен, т.к. администратор должен перевести организационную политику компании в разрешения при настройке ACL. С ростом количества объектов и пользователей в компании у многих пользователей появляются (или остаются после изменения обязанностей) права доступа к некоторым ресурсам, которые им не требуются для работы. Это нарушает принцип минимальных привилегий и увеличивает риски компании. Подход RBAC позволяет избежать этого, так как разрешения управляются на уровне должностных ролей. В модели RBAC роль определяется в терминах операций и задач, которые она выполняет, тогда как в модели DAC описывается, какие субъекты могут иметь доступ к каким объектам.

Например, нам нужна роль аналитика. Мы разрабатываем эту роль, позволяя ей иметь доступ ко всем видам продукции и данным тестирования, а также, что более важно, определяем задачи и операции, которые эта роль может выполнять с этими данными. Когда пользователь, которому присвоена эта роль «Аналитик», делает запрос на доступ к новым результатам тестирования на файловом сервере, операционная система в фоновом режиме просматривает уровень доступа роли, прежде чем эта операция будет разрешена.

    ПРИМЕЧАНИЕ. Введение ролей показывает разницу между правами, назначенными явно и неявно. В явном виде права и разрешения назначаются непосредственно конкретному пользователю. В неявном виде они назначаются роли или группе, а пользователь просто наследует эти полномочия.

Модель RBAC лучше всего подходит для компаний с большой «текучестью» кадров. Если увольняется сотрудник, которому была назначена определенная роль, то новому сотруднику, который займет его место, просто назначается та же роль. Таким образом, администратору не нужно постоянно вносить изменения в ACL отдельных объектов. Ему достаточно создать определенные роли, настроить необходимые этим ролям права и разрешения, а затем назначить пользователям эти роли.





