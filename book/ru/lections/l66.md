# Демонизация программ в ОС Linux. Отличие init.d скриптов от подхода systemctl. Переменные окружения и потоки $1, $2.



## SYSV

**System V** или **SysV** — это довольно старая, но до сих пор еще популярная система инициализации Linux и Unix подобных операционных систем. Она была основой для создания многих других систем инициализации, а также первой коммерческой системой инициализации разработанной для Unix в AT&T. Она была разработана еще в 1983 году.

Задача sysv - запуск служб при старте системы.

В /etc/init.d/ находится файл с именем службы, он отвечает за запуск и остановку. Мы делаем /etc/init.d/service stop или /etc/init.d/service start и все работает отлично.

Операционная система делает то же самое, только в зависимости от runlevel, два — так два, буду последовательно выполнять симлинки из /etc/rc2.d, которые по сути своей ведут к /etc/init.d, жизнь проста и прекрасна. Чтобы управлять последовательностью достаточно изменить сортировку файлов при помощи числа. Есть утилиты, чтобы автоматизировать создание этих симлинков.

### Проблемы SYSV:

На изменения в системе необходимо как-то реагировать. Теперь, когда на лету могут добавляться устройства - состояние системы перестали быть монолитными. Отсюда - необходимость к тому чтобы отслеживать состояния, изменения и дергать за ниточки нужные службы в случае необходимости.
SYSV не отслеживал никак состояние программы на старте. Все это можно было кодить в start скрипте, обкладывать условиями, исключениями и превращать это в что-то монструозное.

SYSV не предоставлял возможности управлять зависимостями, когда одна служба зависит от другой, при этом таких “хотелок” может быть много и они могут быть самыми разнообразными.

Стартующие и останавливающие скрипты не знают о текущем состоянии процесса. Это необходимо отслеживать и проверять. И все опять же в том самом многострадальном файле старта и остановки.

## SYSTEMD

systemd — менеджер системы и сервисов для Linux, демон инициализации других демонов в Linux. Он пришел на замену используемого ранее SysV, но при этом  совместимый с SysV и LSB сценариями.

Его особенностью является интенсивное распараллеливание запуска служб в процессе загрузки системы, что позволяло существенно ускорить запуск операционной системы. Systemd  использует сокет и D-Bus для начала активации сервиса по требованию, запуск демонов в фоновом режиме, отслеживает процессы, использующие Linux cgroups, поддерживает мгновенные снимки и восстановление состояния системы, поддерживает подключения и автоматическое монтирование точек и реализует разработку логики транзакционных зависимостей службы управления.

D-Bus — система межпроцессного взаимодействия, которая позволяет приложениям в операционной системе сообщаться друг с другом.
cgroups (control group) — механизм ядра Linux, который ограничивает и изолирует вычислительные ресурсы (процессорные, сетевые, ресурсы памяти, ресурсы ввода-вывода) для групп процессов. Механизм позволяет образовывать иерархические группы процессов с заданными ресурсными свойствами и обеспечивает программное управление ими.

Название происходит от принятого в Unix добавления суффикса «d» к демонам

### Архитектура

Systemd оперирует специально оформленными файлами конфигурации - юнитами(unit). Каждый юнит отвечает за отдельно взятую службу, точку монтирования, подключаемое устройство, файл подкачки, виртуальную машину и т.п. Существуют специальные типы юнитов, которые не несут функциональной нагрузки, но позволяют задействовать дополнительные возможности systemd. 

Примером таких юнитов являются:

* **.target** - позволяет группировать юниты, воплощая концепцию уровней запуска (runlevel)
* **.service** - отвечает за запуск сервисов (служб), также поддерживает вызов интерпретаторов для исполнения пользовательских скриптов
* **.mount** - отвечает за монтирование файловых систем
* **.automount** - позволяет отложить монтирование файловых систем до фактического обращения к точке монтирования
* **.swap** - отвечает за подключение файла или устройства подкачки
* **.timer** - позволяет запускать юниты по расписанию
* **.socket** - предоставляет службам поддержку механизма сокет-активации
* **.slice** - отвечает за создание контейнера cgroups
* **.device** - позволяет реагировать на подключение устройств
* **.path** - управляет иерархией файловой системы

По сравнению с System V init, systemd даёт преимущества в следующем:
Контроль состояния службы, реакция на изменения состояния
Сокет-активные и шина-активные службы, которые иногда приводят к лучшему распараллеливанию взаимозависимых служб.
cgroups используется для отслеживания служебных процессов, вместо идентификаторов процессов (PID). Это означает, что демоны не будут потеряны даже после разветвления в другие процессы.


При установке программ, инструкции, вшитые в установщик располагают unit-файле в системе. По умолчанию путь расположения этих файлов - /lib/systemd/system.

**/run/systemd/system/** — юниты, созданные в рантайме 
**/etc/systemd/system/**  - место расположения unit-файлов, написанных пользователем.

## UNIT-file

Юнит представляет из себя текстовый файл, обычно называемый по имени службы с которой работает и указанием типа данной службы, например ssh.service

Файл начинается с заголовочной части, где затем идут переменные со значениями

```
[Название секции в квадратных скобках]
имя_переменной = значение
```

В секции Unit описываем, что это за юнит, т.е. его описание.

```
Description=MyUnit
```

Далее следует блок переменных, которые влияют на порядок загрузки сервисов:

Запускать юнит после какого-либо сервиса или группы сервисов (например network.target):

```
After=syslog.target
After=network.target
After=nginx.service
After=mysql.service
```

Для запуска сервиса необходим запущенный сервис mysql:

```
Requires=mysql.service
```

Для запуска сервиса желателен запущенный сервис redis:

```
Wants=redis.service
```

В итоге переменная Wants получается чисто описательной.

Если сервис есть в Requires, но нет в After, то наш сервис будет запущен параллельно с требуемым сервисом, а не после успешной загрузки требуемого сервиса

В секции Service указываем какими командами и под каким пользователем надо запускать сервис:

Тип сервиса:

```
[Service]
Type=simple
```

(по умолчанию): systemd предполагает, что служба будет запущена незамедлительно. Процесс при этом не должен разветвляться. Не используйте этот тип, если другие службы зависят от очередности при запуске данной службы.

```
Type=forking
```

systemd предполагает, что служба запускается однократно и процесс разветвляется с завершением родительского процесса. Данный тип используется для запуска классических демонов.

Также следует определить PIDFile=, чтобы systemd могла отслеживать основной процесс:

```
PIDFile=/work/www/myunit/shared/tmp/pids/service.pid
```

Рабочий каталог, он делается текущим перед запуском стартап команд:

```
WorkingDirectory=/work/www/myunit/current
```


Пользователь и группа, под которым надо стартовать сервис:

```
User=myunit
Group=myunit
```

Переменные окружения:

```
Environment=RACK_ENV=production
```

Запрет на убийство сервиса вследствие нехватки памяти и срабатывания механизма OOM:
-1000 полный запрет (такой у sshd стоит), -100 понизим вероятность.

```
OOMScoreAdjust=-100
```

Команды на старт/стоп и релоад сервиса

```
ExecStart=/path/to/start.script
ExecStop=/path/to/stop.script
ExecReload=/path/to/restart.script
```

Тут есть тонкость — systemd настаивает, чтобы команда указывала на конкретный исполняемый файл. Надо указывать полный путь.

Таймаут в секундах, сколько ждать system отработки старт/стоп команд.

```
TimeoutSec=300
```

Попросим systemd автоматически рестартовать наш сервис, если он вдруг перестанет работать. Контроль ведется по наличию процесса из PID файла

```
Restart=always
```


В секции [Install] опишем, в каком уровне запуска должен стартовать сервис

Уровень запуска:

```
[Install]
WantedBy=multi-user.target
```

multi-user.target или runlevel3.target соответствует нашему привычному runlevel=3 «Многопользовательский режим без графики. Пользователи, как правило, входят в систему при помощи множества консолей или через сеть»

Вот и готов простейший стартап скрипт, он же unit для systemd:

```
myunit.service

[Unit]
Description=MyUnit
After=syslog.target network.target nginx.service mysql.service
Requires=mysql.service
Wants=redis.service

[Service]
Type=forking
PIDFile=/work/www/myunit/shared/tmp/pids/service.pid
WorkingDirectory=/work/www/myunit/current

User=myunit
Group=myunit

Environment=RACK_ENV=production

OOMScoreAdjust=-1000

ExecStart=/usr/local/bin/bundle exec service -C /work/www/myunit/service.rb --daemon
ExecStop=/usr/local/bin/bundle exec service -S /work/www/myunit/pids/service.state stop
ExecReload=/usr/local/bin/bundle exec service -S /work/www/myunit/pids/service.state restart
TimeoutSec=300

[Install]
WantedBy=multi-user.target 


Systemd status
```

После создания файла в папке нужно выполнить команду переинициализации systemd (строго говоря ее надо выполнять каждый раз при изменении любого unit-file)

```
systemctl daemon-reload
```


Systemd управляется с помощью команды systemctl, указанием действия, а затем unit’а, к которому применяется действие:

```
Systemct status myunit

Выведет следующее:
myunit.service - MyUnit
   Loaded: loaded (/etc/systemd/system/myunit.service; disabled)
   Active: inactive (dead)
```

Где видно, что сервис в данный момент не находится в автозапуске (disabled), и сам он не запущен. (inactive, dead)
Для запуска службы нужно указать действие “start”, а для того чтобы сервис запускался при старте системы, нужно указать в качестве действия enable.

В качестве примера создайте службу с вашим докер приложением:

```
[Unit]
Description=xxe
Requires=docker.service
After=docker.service

[Service]
Restart=always
RestartSec=3
ExecStartPre=/bin/sh -c "/usr/bin/docker rm -f blackhat 2> /dev/null || /bin/true"
ExecStart=/usr/bin/docker run --rm -a STDIN -a STDOUT -a STDERR -p 0.0.0.0:8084:80 --name blackhat ctf.school:5000/xxe:2.1
ExecStop=/usr/bin/docker stop blackhat

[Install]
WantedBy=multi-user.target
```
