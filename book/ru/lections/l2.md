# Тема: Файловые системы. Понятие журналируемой файловой системы. Стандарт FHS. Индексный дескриптор. /Proc.

FHS (Filesystem Hierarchy Standard, «стандарт иерархии файловой системы») — стандарт, унифицирующий местонахождение файлов и каталогов с общим назначением в файловой системе UNIX. На данный момент большинство UNIX-подобных систем в той или иной степени следует этим правилам. 
Файловые системы ОС Linux
Файловая система (англ. file system) — порядок, определяющий способ организации, хранения и именования данных на носителях информации в компьютерах, а также в другом электронном оборудовании. Файловая система определяет формат содержимого и способ физического хранения информации, которую принято группировать в виде файлов. Конкретная файловая система определяет размер имен файлов и (каталогов), максимальный возможный размер файла и раздела, набор атрибутов файла. Некоторые файловые системы предоставляют сервисные возможности, например, разграничение доступа или шифрование файлов.

Файловая система связывает носитель информации с одной стороны и API для доступа к файлам — с другой. Когда прикладная программа обращается к файлу, она не имеет никакого представления о том, каким образом расположена информация в конкретном файле, также, как и на каком физическом типе носителя (CD, жёстком диске, магнитной ленте, блоке флеш-памяти или другом) он записан. Всё, что знает программа — это имя файла, его размер и атрибуты. Эти данные она получает от драйвера файловой системы. Именно файловая система устанавливает, где и как будет записан файл на физическом носителе (например, жёстком диске).

С точки зрения операционной системы (ОС), весь диск представляет собой набор кластеров (как правило, размером 512 байт и больше). Драйверы файловой системы организуют кластеры в файлы и каталоги (реально являющиеся файлами, содержащими список файлов в этом каталоге). Эти же драйверы отслеживают, какие из кластеров в настоящее время используются, какие свободны, какие помечены как неисправные.
Однако файловая система не обязательно напрямую связана с физическим носителем информации. Существуют виртуальные файловые системы, а также сетевые файловые системы, которые являются лишь способом доступа к файлам, находящимся на удалённом компьютере.



ext (extended filesystem) — появилась в апреле 1992 года, это была первая файловая система, изготовленная специально под нужды Linux ОС. Разработана Remy Card с целью преодолеть ограничения файловой системы Minix.


JFS (Journaled File System) — файловая система, детище IBM, явившееся миру в далёком 1990 году для ОС AIX (Advanced Interactive eXecutive). В виде первого стабильного релиза, для пользователей Linux, система стала доступна в 2001 году. Из плюсов системы — неплохая масштабируемость. Из минусов — не особо активная поддержка на протяжении всего жизненного цикла. Максимальный рамер тома 32 пэбибайта (32*250 байт).

ext2 (second extended file system) — была разработана Remy Card в 1993 году. Не журналируемая файловая система, это был основной её недостаток, который исправит ext3. 

ext3 (third extended file system) — по сути расширение исконной для Linux ext2, способное к журналированию. Разработана Стивеном Твиди (Stephen Tweedie) в 1999 году, включена в основное ядро Linux в ноябре 2001 года. На фоне других своих сослуживцев обладает более скромным размером пространства, до 4 тебибайт (4*240 байт) для 32-х разрядных систем. На данный момент является наиболее стабильной и поддерживаемой файловой системой в среде Linux.



ReiserFS (Reiser3) — одна из первых журналируемых файловых систем под Linux, разработана Namesys. Имеет некоторые врождённые головные боли, но в целом неплохая система, ведущая отсчёт дней своих с 2001 года. Оговорюсь, что смысл журналируемых систем заключается в дисковых транзакциях, которые последовательно пишутся в специальную зону диска (журнал, он же лог), перед тем как данные попадают в конечные точки файловой системы. Максимальный объём тома для этой системы равен 16 тебибайт (16*240 байт).

Reiser4 — первая попытка создать файловую систему нового поколения для Linux. Впервые представленная в 2004 году, система включает в себя такие передовые технологии как транзакции, задержка выделения пространства, а так же встроенная возможность кодирования и сжатия данных. Ханс Рейзер (Hans Reiser), главный разработчик системы, рекламировал использовать своё детище непосредственно как БД с улучшенными метаданными. После того, как Ханс Рейзер был осуждён за убийство в 2008 году, дальнейшая судьба системы стала сомнительной.

ext4 — попытка создать 64-х битную ext3 способную поддерживать больший размер файловой системы (1 эксбибайт). Позже добавились возможности — непрерывные области дискового пространства, задержка выделения пространства, онлайн дефрагментация и прочие. Обеспечивается прямая совместимость с системой ext3 и ограниченная обратная совместимость при недоступной способности к непрерывным областям дискового пространства.

ZFS (Zettabyte File System) — изначально созданная в Sun Microsystems файловая система, для небезызвестной операционной системы Solaris в 2005 году. Отличительные особенности — отсутствие фрагментации данных как таковой, возможности по управлению снапшотами (snapshots), пулами хранения (storage pools), варьируемый размер блоков, 64-х разрядный механизм контрольных сумм, а также способность адресовать 128 бит информации! В Linux системах может использоваться посредствам FUSE.

Журналируемая файловая система

Журналируемая файловая система — файловая система (ФС), в которой осуществляется ведение журнала, хранящего список изменений и, в той или иной степени, помогающего сохранить целостность файловой системы при сбоях.
Журналируемая файловая система сохраняет список изменений, которые она будет проводить с файловой системой, перед фактическим их осуществлением. Эти записи хранятся в отдельной части файловой системы, называемой журналом (англ. journal) или логом (англ. log). Как только изменения файловой системы внесены в журнал, она применяет эти изменения к файлам или метаданным, а затем удаляет эти записи из журнала. Записи журнала организованы в наборы связанных изменений файловой системы.
При перезагрузке компьютера программа монтирования может гарантировать целостность журналируемой файловой системы простой проверкой лог-файла на наличие ожидаемых, но не произведённых изменений и последующей записью их в файловую систему. То есть, при наличии журнала в большинстве случаев системе не нужно проводить проверку целостности файловой системы. Соответственно, шансы потери данных в связи с проблемами в файловой системе значительно снижаются.
По типу внесения в журнал журналируемые ФС подразделяются на
в режиме обратной связи (журналируются только метаданные): XFS, ext3;
упорядоченные (журналируются только метаданные синхронно относительно данных): JFS2, ext3 (по умолчанию), ReiserFS (основной);
в режиме данных (журналируются как метаданные, так и данные): ext3;

Структура каталогов
В FHS все файлы и каталоги находятся внутри корневого каталога, даже если они расположены на различных физических носителях. Однако некоторые из каталогов могут присутствовать только в случае, если установлено определённое программное обеспечение, такое как, например, X Window System. Большая часть этих каталогов существует во всех UNIX-подобных операционных системах и используется похожим образом.


/ 
Корневой каталог, содержащий всю файловую иерархию.
/bin


Основные утилиты, необходимые как в однопользовательском режиме, так и при обычной работе всем пользователям (например: cat, ls, cp).
/boot
Загрузочные файлы (в том числе файлы загрузчика, ядро, initrd, System.map). Часто выносится на отдельный раздел.
/dev


Основные файлы устройств (например, /dev/null, /dev/zero).
/etc
Общесистемные конфигурационные файлы (имя происходит от лат. et cetera).
/etc/opt
Файлы конфигурации для /opt.
/etc/X11
Файлы конфигурации X Window System версии 11.
/home
Содержит домашние каталоги пользователей, которые в свою очередь содержат персональные настройки и данные пользователя.
/lib
Основные библиотеки, необходимые для работы программ из /bin и /sbin.
/media
Точки монтирования для сменных носителей, таких как CD-ROM, DVD-ROM
/mnt
Содержит временно монтируемые файловые системы.
/opt
Дополнительное программное обеспечение.
/proc
Виртуальная файловая система, представляющая состояние ядра операционной системы и запущенных процессов в виде файлов.
/root
Домашний каталог пользователя root.
/sbin
Основные системные программы для администрирования и настройки системы, например, init, iptables, ifconfig.
/srv
Данные для сервисов, предоставляемых системой (например, www или ftp).
/tmp
Временные файлы (см. также /var/tmp).
/usr


Вторичная иерархия для данных пользователя. Содержит большинство пользовательских приложений и утилит, используемых в многопользовательском режиме. Может быть смонтирована по сети только для чтения и быть общей для нескольких машин.
/usr/bin


Дополнительные программы для всех пользователей, не являющиеся необходимыми в однопользовательском режиме.
/usr/include
Стандартные заголовочные файлы.
/usr/lib
Библиотеки для программ, находящихся в /usr/bin и /usr/sbin.
/usr/sbin


Дополнительные системные программы (такие как демоны различных сетевых сервисов).
/usr/share
Архитектурно-независимые общие данные.
/usr/src


Исходные коды (например, здесь располагаются исходные коды ядра).
/usr/local


Третичная иерархия для данных, специфичных для данного хоста. Обычно содержит такие подкаталоги, как bin, lib, share.
/var


Изменяемые файлы, такие как файлы регистрации, временные почтовые файлы, файлы баз данных, spool итп.
/var/cache


Кэш приложений. Такие данные генерируются локально в результате ресурсозатратных вычислений или операций ввода-вывода. Приложение обязано уметь регенерировать эти данные. Данные файлы могут быть удалены без потери данных.
/var/lib


Информация о состоянии. Постоянные данные, изменяемые программами в процессе работы (например, базы данных, метаданные пакетного менеджера и др.).
/var/lock
Файлы блокировки, указывающие на занятость некоторого ресурса.
/var/log
Логи.
/var/mail
Почтовые ящики пользователей.
/var/run
Информация о запущенных программах (в основном, о демонах). (симлинк)
/var/spool
Задачи, ожидающие обработки (например, очереди печати, непрочитанные или неотправленные письма).
/var/tmp
Временные файлы, которые должны быть сохранены между перезагрузками.

Индексный дескриптор
В информатике inode (произносится а́йнод или ино́д), индексный дескриптор — это структура данных в традиционных для ОС UNIX файловых системах (ФС), таких как UFS, ext4. В этой структуре хранится метаинформация о стандартных файлах, каталогах или других объектах файловой системы, кроме непосредственно данных и имени.
Пример: df -i
Жёсткой ссылкой (англ. hard link) в UFS-совместимых файловых системах называется структурная составляющая файла — описывающий его элемент каталога.
Файл в UFS представляет собой структуру блоков данных на диске, имеющую уникальный индексный дескриптор (или i-node) и набор атрибутов (метаинформацию). Жёсткая ссылка связывает индексный дескриптор файла с каталогом и дает ему имя.
У файла может быть несколько жёстких ссылок: в таком случае он будет фигурировать на диске одновременно в различных каталогах или под различными именами в одном каталоге.
 При редактировании файла через одну из ссылок на него, содержимое по другим ссылкам тоже изменится.
Количество жёстких ссылок файла сохраняется на уровне файловой системы в метаинформации. Файлы с нулевым количеством ссылок перестают существовать для системы и, со временем, будут перезаписаны физически. Дополнительную ссылку в UNIX можно создать с помощью команды ln. Все ссылки одного файла равноправны и неотличимы друг от друга — нельзя сказать, что файл существует в таком-то каталоге, а в других местах есть лишь их копии. Удаление ссылки приводит к удалению файла лишь в том случае, когда это была последняя ссылка, любая из созданных, то есть все остальные жёсткие ссылки на него уже удалены
Большинство программ не различают жёсткие ссылки одного файла.
В связи с тем, что жёсткие ссылки ссылаются на индексный дескриптор, уникальный в пределах дискового раздела, создание жёсткой ссылки на файл в каталоге другого раздела невозможно. Для преодоления этого ограничения используются символьные (символические) ссылки.
Символическая («мягкая») ссылка (также «симлинк», от англ. Symbolic link) — специальный файл в файловой системе, в котором вместо пользовательских данных содержится путь к файлу, открываемому при обращении к данной ссылке (файлу).
Целью ссылки может быть любой объект: например другая ссылка, файл, каталог или даже несуществующий файл (в последнем случае при попытке открыть его должно выдаваться сообщение об отсутствии файла). Ссылка, указывающая на несуществующий файл, называется висячей или битой.
Символические ссылки используются для более удобной организации структуры файлов на компьютере, так как:
позволяют для одного файла или каталога иметь несколько имён и различных атрибутов;
свободны от некоторых ограничений, присущих жёстким ссылкам (последние действуют только в пределах одной файловой системы (одного раздела) и не могут ссылаться на каталоги).
Пример: ln -s файл имя_ссылки
Порядок монтирования файловой системы 
fstab (сокр. от англ. file systems table) — один из конфигурационных файлов в UNIX-подобных системах, который содержит информацию о различных файловых системах и устройствах хранения информации компьютера; описывает, как диск (раздел) будет использоваться или как будет интегрирован в систему.
Полный путь к файлу — /etc/fstab.
аждая запись имеет следующие поля (которые разделяются пробелом или табуляцией):
<file system>        <dir>     <type>    <options> <dump>    <pass>


Поле, <file system> (файловая система) сообщает демону монтирования файловых систем mount, что монтировать, имя монтируемого устройства.
Второе поле, <dir> (директория), определяет путь, по которому будет смонтирована <file system>.
Поле <type> (тип) содержит тип файловой системы монтируемого устройства. Полный список поддерживаемых систем можно просмотреть выполнив команду:

Пример: man mount

Список ключей монтирования:
rw (read-write, чтение-запись) - файловая система будет подключена с возможностью записи на неё пользователями.
exec - все файлы на подключемой системе будут считаться исполнимыми, если система не поддерживает других механизмов указания исполнимости файла. Альтернативно, noexecзапрещает исполнение любых бинарных файлов вообще.
codepage=866 - указывает, какую кодировку использовать для трансляции имён файлов на файловой системе. Кириллическая русская кодовая страница для файловой системы FAT - 866. Длинные имена на файловой системе (VFAT) сохраняются в уникоде, реально эта настройка нужна только для дисков, записанных на отличных от Windows системах, не поддерживающих соглашения VFAT.
nls=utf8 - указывает модулю файловой системы, какую кодировку использовать при передаче данных системе (и пользователю). Старое название этой опции - iocharset использовать запрещено - она будет удалена в следующих версиях программы.
uid (gid) - указывает, какой пользователь (группа) будет владеть точкой подключения (и файлами на ней, если нет других способов определить владельца). gid=plugdev указывает, что все пользователи в группе 46(plugdev) могут обращаться к этому устройству. Локальные пользователи в Ubuntu обычно входят в эту группу.
umask=0002 - подробности смотрите в __man chmod__
nofail - если указанный том недоступен в момент загрузки, это не создаст ошибок и загрузка нормально продолжится.
Внимание: настольная (desktop) версия Ubuntu всё равно выдаст предупреждение и будет ждать ввода пользователя.
users - допускает монтирование и размонтирование устройства обычными пользователями, причём, в отличие от user, размонтировать устройство может любой пользователь, не обязательно тот, что его монтировал.

Стоит обратить внимание на тот факт, что <options> могут быть составлены из нескольких значений разделенных запятой.
Пример обычного файла fstab:
# <file system>        <dir>         <type>    <options>          <dump> <pass>
none                   /dev/pts      devpts    defaults            0      0
none                   /dev/shm      tmpfs     defaults            0      0
/dev/cdrom             /mnt/cd   iso9660   ro,user,noauto,unhide   0      0
/dev/dvd               /mnt/dvd  udf       ro,user,noauto,unhide   0      0
/dev/fd0               /mnt/fl   auto      user,noauto             0      0
/dev/hda1              swap       swap      defaults               0      0
/dev/hda4              /          ext3      defaults               0      1
/dev/hda3              /home      xfs       rw,suid,exec,auto,nouser,async 0      2

Монтирование может осуществляться не только по имени диска, но и по его персональному идентификатору.

Пример нахождения UUID: sudo blkid
/dev/sda1: UUID="00a4ad8e-dbcc-4c32-a0b4-074b5ee2bfb4" TYPE="ext4" 
/dev/sda2: LABEL="Win7" UUID="0E42D6D242D6BE21" TYPE="ntfs" 
/dev/sda3: LABEL="Shared" UUID="7ECCC7F5CCC7A62D" TYPE="ntfs" 
/dev/sda4: UUID="1050e484-896f-42a9-bdb3-49eb1255cc77" TYPE="swap" 
/dev/sr0: LABEL="DrWebLiveCD" TYPE="iso9660" 
/dev/sdb1: LABEL="TRENDNET8GB" UUID="355B-FE37" TYPE="vfat"

Добавляем в /etc/fstab:
UUID="7ECCC7F5CCC7A62D" /mnt/Shared ntfs rw,nls=utf8,gid=plugdev,umask=0002 0 0

Предназначение /proc

Linux имеет отличный способ изменять параметры ядра во время работы системы и без необходимости перезагрузки. Это делается при помощи виртуальной файловой системы /proc. Linux Gazette дает один из простейших и легчайших объяснений /proc, которые я когда-либо видел.

Вкратце, файловая система /proc дает вам возможность заглянуть в работающее ядро, что может быть полезно для мониторинга производительности, проверки системной информации, конфигурирования системы и изменения конфигурации. Эта файловая система называется виртуальной, потому что это в действительности не файловая система. Это карта, создаваемая ядром и присоединяемая к вашей обычной файловой системе, чтобы обеспечить доступ. Тот факт, что мы можем разным  способами внести изменения в ядро во время работы системы дает  системному администратору огромную мощь и гибкость при изменении параметров.

Но может быть слишком много власти это плохо? Иногда. Если вы собираетесь внести изменения в файловую систему /proc, вы должны быть уверены, что вы знаете, что вы делаете и какой эффект произведут на систему ваши действия. Это очень полезная техника, но одно неверное движение может вызвать неожиданные последствия. Если вы не уверены и новичок в таких делах, попрактикуйтесь на машине с меньшей важностью для ваших дел.

Сначала, подумайте о том, как не вносить изменения в ядро. Есть две отличных причины, почему вам не стоит просто перейти в /proc, открыть файл в текстовом редакторе, сделать несколько изменений и сохранить файл. Вот они:

Целостность данных: Все эти файлы представляют работающую систему, а поскольку ядро может внести изменения в эти файлы в любое время, то если вы откроете файл и попытаетесь внести изменения в то время, когда туда вносит изменения система, то вы можете сохранить не то, что ожидает увидеть ядро.


Виртуальные файлы: Все эти файлы в действительности не существуют.


Как же тогда синхронизировать сохраненные данные?


Ответом на это является не использование текстового редактора для внесения изменений. Поэтому для внесения изменения в что-либо в файловой системе /proc, вам следует использовать команду echo и перенаправлять вывод команды в выбранный файл в /proc.


Например: echo "Your-New-Kernel-Value" > /proc/your/file


Аналогично, если вы хотите увидеть информацию из /proc, вам следует использовать либо команду, которая предназначена для этого, либо команду cat.


Вам не нужно быть разработчиком ядра, чтобы пользоваться /proc, а базовое понимание этой структуры отлично вам поможет. Вы можете найти, что вам не нужно знать обо всем в /proc, до тех пор пока пользователь не попросит вас увеличить производительность и вы должны будете изучить куда вносить изменения. Файловая система /proc помогает администратору в этом через свою структуру и атрибуты файлов.


Каждый файл в /proc имеет особый набор атрибутов и может принадлежать конкретному пользователю по его ID. Сделано это очень аккуратно, так что правильная работа обеспечена и администратору и пользователям.

Следующий список обобщает какие атрибуты могут быть у файлов:
Read-only: Файл не может быть изменен ни каким пользователем; используется для представления системной информации
Root-write: Если файл может быть изменен, то изменения может вносить только пользователь root
Root-read: Некоторые файлы могут быть не читаемы для обычных пользователей системы, только для root
Other: Вы можете найти другие комбинации, чем перечисленные выше, по различным причинам

В основном в /proc вы найдете файлы read-only за исключением /proc/sys, которая содержит большинство параметров ядра и предназначена для изменения во время работы системы. Как результат в этой лекции рассматривается в основном эта директория.


Последнее, что вам нужно знать о изменении файлов в /proc - это то, что нужно записывать в эти файлы. Вы заметите, что некоторые из файлов могут быть легко прочитаны человеком, а некоторые являются файлами данных и могут быть прочитаны только при специальных утилит таких как top, lspci,и free. Вы также заметите, что эти легко читаемые файлы имеют два различных формата: некоторые являются бинарными ключами, а другие содержат больше информации. Файлы с бинарными ключами содержат только 0 (выключено) или 1 (включено) для некоторых функций ядра.



Пример: /proc/sys/fs/file-max


Здесь указывается максимальное количество заголовков файлов, которое может быть одновременно открыто. Вам может понадобиться увеличить это число если пользователи получают сообщение об ошибке потому что достигнуто максимальное количество открытых файлов. Можно указать любое числовое значение в этом файле. Default setting: 4096


