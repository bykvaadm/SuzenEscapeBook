Команда Ln
Команда ln создает запись в директории (ссылку) с именем, целевой_файл. На целевой_файл будут установлены теже режимы, которые стоят на исходный_файл. Ссылки позволяют иметь несколько копий одного файла или каталога, размещенных в разных местах, но не занимая при этом дисковое пространство. Существует два типа ссылок, жесткие ссылки и символические ссылки. Каким образом ссылка указывает на исходный_файл, зависит от типа данной ссылки.
Задача: Команда Ln создает жесткую или символьную ссылку на каталог или файл. Проверим, так ли это.
Решение: 
Создадим два файла, для этого воспользуемся командой touch и воспользуемся командой  ls –l, для того что бы удостовериться, что ссылка создалась:

В дальнейшем мы будем использовать эти файлы постоянно.
Сделаем ссылку на file1.txt, для этого воспользуемся командой 
ln /home/diex/practice/file1.txt mylink1

Попробуем создать символьную ссылку на каталог /home/diex/practise, для этого воспользуемся ключом –s:
Ln –s /home/diex/practice mylinks

Удостоверимся, что ссылка рабочая, воспользуемся командой
cd mylinks, что бы перейти по ссылке:

 
Опции
    1. Опция –b
Задача: Создать резервную копию целевого файла.
Решение: Возьмем файл file1.txt и создадим его резервную копию, с помощью команды:
Ln –b file1.txt filebackup


    2. Опция –b, -F
Задача: Позволить суперпользователю создать жесткие ссылки на каталоги  (операция не удастся из-за системных ограничений, даже для суперпользователя). 
Решение: Воспользуемся данной опцией для создания ссылки:
Ln –b –F /home/diex/practice/ link1


    3. Опция –f
Задача: Если целевой_файл или файлы уже существуют, то перезаписать их.
Решение: Запишем в файл file1.txt строчку “Hello World!” при помощи команды 
echo “Hello World!” > file1.txt 

и посмотрим его содержимое при помощи команды
head file1.txt

Далее воспользуемся нашей опцией –f:


    4. Опция –i
Задача: Спрашивать пользователя перед перезаписью файла.
Решение: Имеем три файла, содержимое первого  узнаем при помощи команды :
head file1.txt,
содержимое второго файла, при помощи команды :
head file2.txt
и содержимое третьего при помощи:
head filenew.txt.
Далее используем опцию –i, которая спрашивает у пользователя о перезаписи:
ln –i file2.txt filenew.txt
После проверяем, что получилось в файле file2.txt, с помощью команды 
head filenew.txt


    5. Опция –L
Задача: Создание ссылки на символическую ссылку
Решение: Создадим символьную ссылку на file1.txt, с помощью команды 
ln –s file1.txt link1
Далее создадим ссылку на символьную ссылку, используя опцию -L:
ln –L link1 link2
Далее проверим, куда указывает link2, при помощи команды 
head link2
 

















Команда locate
    Если команда find выполняется слишком долго, то можно попробовать воспользоваться командой locate. Команда locate выполняет поиск по всей файловой системе примерно, как и команда find, однако поиск ведётся по базе данных, а не по самой файловой системе, что обуславливает её быстроту. Данный подход имеет массу преимуществ, но он не лишён и недостатков. Основной его недостаток заключается в том, что после создания каждого нового файла или новой директории для корректной работы утилиты приходится обновлять информацию в базе данных. В противном случае утилита не сможет найти файлы и директории, созданные после последнего обновления информации в базе данных. Обновление базы данных выполняется автоматически каждое утро, чтобы у вас был всегда более свежий список файлов своей системы. Также процесс обновления можно запустить вручную, при помощи updated. Перед этим необходимо получить root-права, с помощью команды su.

Опции команды locate
-n
Ограничение количества возвращаемых результатов
-c
Поиск числа найденных файлов
-i
Поиск без учета регистра
-e
Отображение только файлов, существующих в системе
-0
Вывод записей без символа «новая строка»
-S
Обзор вашей локальной базы данных locate
-q
Подавление сообщений об ошибках
-d
Выбор другого расположения mlocate
-b
Игнорирование пути до файла при поиске


Использование команды locate
Для того чтобы найти конкретные файлы в системе, всё что вам необходимо сделать, так это передать команде locate имя файла, который необходимо найти. (Также файлы можно найти при помощи регулярных выражений, например, «locate –r /test_1$».)
 Заранее я создал два файла с именами «test_1» и «mork_file_1». Давайте попробуем их найти при помощи команды locate.

Для начала я вхожу под root-правами, далее обновляю список файлов в файловой системе и наконец при помощи команды locate нахожу нужные мне файлы. Также, если вы хотите найти все файлы в именах которых содержится определённая строка, то вы можете сделать это следующим образом: Например, мне нужно найти все файлы где присутствует строка «mork». Для этого нужно с обеих сторон поставить *.

















Для того чтобы вместо имён найденных файлов с их полными и абсолютными путями утилита locate выводила лишь информацию о количестве найденных файлов и директорий, можно воспользоваться параметром –с. 





Как стало видно я воспользовался данным параметром и обнаружил, что количество найденных файлов, в которых присутствует строка «mork» 158 штук.
      Далее затрагивается проблема о выводе информации лишь о существующих в данный момент файлах. Для наглядности я удалю файл, созданный ранее «test_1». Для того чтобы проверить действительно ли это так воспользуемся командой find, а затем locate.



Как видим команда find не может найти данный файл, а утилита locate спокойно нам демонстрирует в какой директории этот файл находится. 
Для того чтобы это исправить, можно воспользоваться параметром –e.

Как видим теперь утилита locate показывает, что такого файла в системе нет.
     Далее рассмотрим параметр – i, при помощи которого locate будет игнорировать регистр символов имен файлов. Для наглядности я создам два файла с именами «math_geom» и «MATH_GEOM».









Как видно из примера, если не использовать параметр –i то утилита locate находит только один файл, а если использовать, то два, невзирая на регистр имён.
Если вам необходима информация об используемой утилитой locate базе данных, а также статистических данных, касающихся этой базы данных, вы можете воспользоваться параметром –S.










  

Команда whereis
Данная команда используется для того, чтобы определить в каком каталоге расположена искомая команда, её исходный код и соответствующая страница документации. В отличие от find или locate, здесь вам потребуется точное знание названия команды. К недостаткам команды whereis можно отнести то, что она просматривает только каталоги, включенные в специальный список. По этой причине она не сможет найти новую команду или страницу руководства, которую вы только что инсталлировали.

Опции команды whereis
-b
Искать путь только к исходным файлам
-m
Искать путь только к документации
-s
Искать путь только к источникам
-u
Поиск необычных записей
-B
Ограничение поиска исходных файлов
-M
Ограничение поиска руководств
-S
Ограничение поиска источника
-f
Сообщение о начале имен файлов
-v
Показать информацию о версии
-h
Показать подсказки
  
*Файл считается необычным, если у него нет ни одной записи запрошенного типа

Использование команды whereis
Например, если вы хотите узнать, где содержится определённая команда Unix, в данном случае команда sudo, то стоит воспользоваться whereis <название команды>





В основном команду whereis используют для нахождения только исполняемых файлов команд. И для удобства пользования существует специальная опция –b.







Если вы хотите выполнить поиск исполняемого файла по пути, отличному от пути по – умолчанию, заданному whereis, то вы можете использовать опцию -B и указать путь в качестве аргумента. (Изменение или иное ограничение мест, где whereis ищет исходные файлы)



Также команда whereis ищет программы среди стандартных директорий. Для наглядности я установил программу Midnight Commander, посмотрим, что нам даст вызов whereis.



  

Команда find
Find — это одна из наиболее важных и часто используемых утилит системы Linux. Это команда для поиска файлов и каталогов на основе специальных условий. Ее можно использовать в различных обстоятельствах, например, для поиска файлов по разрешениям, владельцам, группам, типу, размеру и другим подобным критериям.
Утилита find предустановлена по умолчанию во всех Linux дистрибутивах, поэтому нам не нужно будет устанавливать никаких дополнительных пакетов. Это очень важная находка для тех, кто хочет использовать командную строку наиболее эффективно.
Команда find имеет такой синтаксис:
find [папка] [параметры] критерий шаблон [действие]
Папка — каталог в котором будем искать
Параметры — дополнительные параметры, например, глубина поиска, и  т .д.
Критерий — по какому критерию будем искать: имя, дата создания, права, владелец и т д.
Шаблон — непосредственно значение, по которому будем отбирать файлы.

 ОСНОВНЫЕ ПАРАМЕТРЫ КОМАНДЫ FIND
Есть очень много  параметров, и я решила рассмотреть только самые полезные.
    • -P никогда не открывать символические ссылки
    • -L — получает информацию о файлах по символическим ссылкам. Важно для дальнейшей обработки, чтобы обрабатывалась не ссылка, а сам файл.
    • -maxdepth — максимальная глубина поиска по подкаталогам, для поиска только в текущем каталоге установите 1.
    • -depth — искать сначала в текущем каталоге, а потом в подкаталогах
    • -mount искать файлы только в этой файловой системе.
    • -version — показать версию утилиты find
    • -print — выводить полные имена файлов
    • -type f — искать только файлы
    • -type d — поиск папки в Linux


КРИТЕРИИ:

Критериев у команды find в Linux очень много, и я опять же продемонстрирую только основные.
    • -name — поиск файлов по имени
    • -perm — поиск файлов в Linux по режиму доступа
    • -user — поиск файлов по владельцу
    • -group — поиск по группе
    • -mtime — поиск по времени модификации файла
    • -atime — поиск файлов по дате последнего чтения
    • -nogroup — поиск файлов, не принадлежащих ни одной группе
    • -nouser — поиск файлов без владельцев
    • -newer — найти файлы новее чем указанный
    • -size — поиск файлов в Linux по их размеру


ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ команды find:

Задача 1: Найти файл 
Показать все существующие файлы в директории:



Задача 2: найти файл в определенной папке:
Показать все файлы в указанной директории:


Искать файлы по имени в текущей папке:

    • find ~ -name '*.doc'
    • ~
домашняя папка пользователя в качестве начального пути для поиска
    • -name
поиск по имени файла
Так же можно делать поиск по части имени
find ~ -name 'cat.*'
find ~ -name '*.doc'
У параметра name есть альтернатива iname — игнорирование регистра символов.
 find ~ -name '*.png'


задача 3: найти файл с ограничением глубины поиска:
Команда find также позволяет ограничить глубину поиска файлов определенным количеством поддиректорий. Для этого предназначен параметр -maxdepth.
Например, предположим, что имеется следующая структура директорий:
find . -maxdepth 3 -name "*.png"


задача 4: ИНВЕРТИРОВАНИЕ ШАБЛОНА:
Найти файлы, которые не соответствуют шаблону:
find . -not -name "test*"




задача 5: найти файл с НЕСКОЛЬКими КРИТЕРИями:
Поиск командой find в Linux по нескольким критериям, с оператором исключения:
 find . -name "test" -not -name "*.png" 

задача 6: найти файл с НЕСКОЛЬКими КАТАЛОГами:

Искать в двух каталогах одновременно:
 find ./test ./test2 -type f -name "*.png"



задача 7:найти СКРЫТЫе ФАЙЛы:

Найти скрытые файлы:
 find ~ -type f -name ".*"



















LVM
LVM или Logical Volume Manager — это еще один программный уровень абстракции над физическими разделами жесткого диска, который позволяет создавать логические тома для хранения данных без непосредственной переразметки жесткого диска на одном или нескольких жестких дисках. LVM увеличивает удобство работы с жестким диском, аппаратные особенности работы скрываются программным обеспечением, поэтому вы можете изменять размеры дисков, перемещать их на лету, без остановки приложений или размонтирования файловых систем. Это очень удобно на серверах, вы можете добавить еще один диск или расширить существующие lvm тома на лету.
  
LVM работает на уровне ядра, поэтому гарантируется максимальная прозрачность настройки и использования дисков. Программы смогут работать с логическими, виртуальными lvm разделами, точно так же, как и с обычными.
Вот преимущества использования LVM перед обычными разделами жесткого диска.
    • Легкое изменение размера — вы можете расширить или уменьшить lvm раздел без переформатирования диска
    • Легкая расширяемость пространства — вы можете увеличить доступное пространство, просто добавляя новые физические диски в общий пул памяти LVM, таким образом, вы получаете большую гибкость.
    • Резервное копирование и зеркалирование данных — возможность записи на несколько дисков одновременно позволяет увеличить производительность работы системы, а также есть возможность настроить зеркалирование данных и резервное копирование разделов для увеличения безопасности.
    • Читаемые имена — вы можете давать любые имена вашим логическим разделам, так чтобы они соответствовали назначению раздела и легко запоминались.

А сейчас я продемонстрирую создание LVM, настройку и работу с дисками. 



СОЗДАНИЕ LVM LINUX:

Есть 3 уровня абстракции:

1. PV (Physical Volume) — физические тома (это могут быть разделы или целые «неразбитые» диски)
2. VG (Volume Group) — группа томов (объединяем физические тома (PV) в группу, создаём единый диск, который будем дальше разбивать так, как нам хочется)
3. LV (Logical Volume)  — логические разделы, собственно раздел нашего нового «единого диска» Группы Томов, который мы потом форматируем и используем как обычный раздел, обычного жёсткого диска.

Перед тем как начинать создание lvm linux необходимо установить нужные для этого инструменты:

Соответственно структуре LVM, нам нужно будет инициализировать физические разделы для LVM, объединить их в группу, а затем создать из этой группы нужные нам логические тома.
ИНИЦИАЛИЗАЦИЯ ФИЗИЧЕСКИХ LVM РАЗДЕЛОВ:

Сначала определимся с томами, которые будем использовать, допустим, это будут /dev/sda6 и /dev/sda7. Инициализировать их для работы LVM можно с помощью команды pvcreate:


Чтобы посмотреть действительно ли были созданы физические тома LVM то, нужно использовать команду pvcsan:

Также можно посмотреть физические LVM разделы с более подробными атрибутами, такими как размер, общий размер, физический размер, свободное место и т д:


PE Size — это размер одного блока LVM, по умолчанию он равен четырем мегабайтам, но это значение можно изменить.


СОЗДАНИЕ ГРУППЫ РАЗДЕЛОВ LVM:
Группа томов — это не что иное, как пул памяти, который будет распределен между логическими томами и может состоять из нескольких физических разделов. После того как физические разделы инициализированы, то можете создать из них группу томов (Volume Group, VG):


С помощью lvm команды vgdisplay можно посмотреть созданные группы томов:




    СОЗДАНИЕ ЛОГИЧЕСКИХ ТОМОВ LVM:

Теперь все готово, чтобы создать логические LVM разделы. Для этого буду использовать команду lvcreate и создам логический раздел размером 80 Мегабайт, или 20 блоков LVM:

Посмотреть список доступных логических разделов LVM можно по аналогии с предыдущими разделами с помощью команды lvdisplay:

Теперь, когда раздел создан, можно работать с ним как и с обычным разделом. Например, отформатируем его в файловую систему ext4, а затем примонтирую в /mnt:

Как видите, монтирование lvm linux ничем не отличается от монтирования обычных разделов.
Вообще говоря, lvm разделы могут быть трех типов:
    • Линейные разделы (linear volume)
    • Полосные разделы (Striped Volume)
    • Зеркалированные разделы (Mirrored Volume)

Линейные разделы — это обычные LVM тома, они могут быть созданы как их одного, так и нескольких физических дисков. Например, если у вас есть два диска по 2 гигабайта, то вы можете их объединить и в результате получите один раздел LVM linux, размером 4 гигабайта. По умолчанию используются именно линейные LVM разделы.
Полосные разделы очень полезны при больших нагрузках на жесткий диск. Здесь вы можете настроить одновременную запись на разные физические устройства, для одновременных операций, это может очень сильно увеличить производительность работы системы.
Для этого нужно задать количество полос записи с помощью опции -i, а также размер полосы опцией -l. Количество полос не должно превышать количества физических дисков. Например:

Зеркалированный том позволяет записывать данные одновременно на два устройства. Когда данные пишутся на один диск, они сразу же копируются на другой. Это позволяет защититься от сбоев одного из дисков. Если один из дисков испортится, то разделы LVM просто станут линейными и все данные по-прежнему будут доступны. 
Для создания такого раздела LVM Linux можно использовать команду:

УДАЛИТЬ LVM РАЗДЕЛ:
Вы можете не только настроить lvm тома изменяя их размер и атрибуты, но и удалить lvm раздел, если он вам больше не нужен. Это делается с помощью lvm команды lvremove:

Теперь лишний раздел удален.
ИЗМЕНЕНИЕ РАЗМЕРА LVM ТОМА:

Вы можете изменять уже созданные разделы LVM увеличивая или уменьшая их размер. Причем неважно есть ли место на физическом диске после этого раздела, если в пуле есть память, вы можете ее использовать для любого раздела. Чтобы изменить размер lvm нужно использовать команду lvextend. 
Например, lvm увеличим размер диска из 80 до 100 мегабайт:

Также можем увеличить размер lvm, использовав знак +:

Точно так же можно выполнить уменьшение lvm раздела с помощью знака -.


Команда diff
Для сравнения двух или нескольких файлов в Linux есть команда diff. Она может сравнивать как отдельные файлы, так и каталоги. Рассмотрим синтаксис, опции команды diff и несколько примеров использования.
Задача: Сравнить два файла
Решение: Для начала рассмотрим содержимое двух файлов, при помощи команды head:
Первый файл:

Второй файл:

Далее сравним  файлы:

Несложно заметить, что вывод в данном формате плохо читается, так как предназначен для программной обработки. Служебные метки имеют формат [номер строки или диапазон строк первого файла][действие][номер строки или диапазон строк второго файла]. Для описания действий используются буквенные символы, а именно, a — добавление, c — изменение и d — удаление. В данном случае метка 1,2d0 обозначает, что строки с первой по вторую должны быть удалены из начала первого файла, а метка 3a2,6 — что после третьей строки в первый файл должны быть добавлены строки со второй по шестую из второго файла. Добавляемые и удаляемые строки обозначаются с помощью символов > и < соответственно.

Опции
    1. Опция –q
Задача: Производит вывод только тогда, когда файлы отличаются, если нет различия, то ничего не выводит.
Решение: Сравним два файла, с помощью команды head узнаем содержимое этих файлов:
Первый файл: 
head file1.txt

Второй файл:
head file2.txt
 
Сравним два файла с опцией -q:
diff –q file1.txt file2.txt 




    2. Опция –c
Задача: Копируемый контекст вывода
Решение: Сравним файлы, используя опцию –с:

Как можно заметить, перед словом sky стоит “-”, а это значит, что фалы отличаются именно этим словом!

    3. Опция –u
Задача: Унифицированный контекстный вывод
Решение: Сравним файлы, используя опцию –u:

В случае использования этого формата вывода символы "+" и "-" перед строками соответствуют различиям в файлах: с помощью символа "-" маркируются строки из файла с именем file1, отсутствующие в файле с именем file2.txt, а с помощью символа "+" - строки из файла с именем file2, которые должны быть добавлены в файл с именем file1.txt.

    4. Опция –N
Задача: Обработка отсутствующих файлов как пустых
Решение: Утилита diff также поддерживает параметр, с помощью которого вы можете сообщить ей о том, что следует рассматривать отсутствующие файлы как пустые. Если вы сравните файлы с именами file1 и file3 (причем последнего файла не существует), по умолчанию diff выведет сообщение об ошибке:


В этом нет ничего плохого; по сути, данное поведение является вполне обоснованным. Но бывают случаи, когда необходимо избежать вывода сообщений об ошибках (возможно, при использовании diff в рамках сценариев командной оболочки), в которых вы можете воспользоваться параметром -N для обработки отсутствующих файлов как пустых и продолжения сравнения файлов.


















Команда chmod
Команда chmod представляет из себя удобный инструмент для повешения безопасности ОС и позволяет назначить права доступа к файлам или каталогам.

Если ты суперпользователь, то можешь спокойно изменять права доступа у любого файла и каталога, которые могут принадлежать любому пользователю системы.

Если ты обычный юзер, то ты можешь изменять только созданные тобой файлы и каталоги.

Для того чтоб настраивать права, нам понадобиться знать следующие виды прав:
1) r — чтение;
2)w — запись;
3) x — выполнение;
4) s — выполнение от имени суперпользователя;

Так же есть категория пользователей, для которых мы и устанавливаем эти права:
1) u — владелец файла;
2) g — группа файла;
3) o — все остальные пользователи;

Синтаксис настройки прав следующий -
группа_пользователейдейстивевид_прав

Действием могут быть как + (включать) так и — (отключать)
Примеры:
1) u+x — разрешить выполнение для владельца;
2) ugo+x — разрешить выполнение для всех;
3) o-x — запретить выполнение для остальных пользователей;
4) ugo+rwx — разрешить все для всех;

Так же права можно записывать другим способом. Есть восьмеричный формат записи, он сложнее в понимании, но пишется легче и короче.
1) 0 — никаких прав;
2) 1 — только выполнение;
3) 2 — только запись;
4) 3 — выполнение и запись;
5) 4 — только чтение;
6) 5 — чтение и выполнение;
7) 6 — чтение и запись;
8) 7 — чтение, запись и выполнение;

Права на папку или файл устанавливается следующим образом. Первой цифрой указывается права для владельца, затем для группы, а потом для остальных. Пример:
1) 744 — разрешить все для владельца, а остальным только чтение;
2) 777 — всем все разрешено;

Так же параметры можно указывать следующим образом:
    • u=rwx
    • g=rw-x
    • o=---
Это дольше писать, чем 750, но куда эффективнее воспринимается новичками в изучении ограничения доступа к файлам.


Теперь рассмотрим колючи команды:
1) -c — выводить информацию обо всех изменения;
2) -f — не выводить сообщение об ошибках;
3) -v — выводит диагностику для каждого обработанного файла
4) --preserve-root — не выполнять рекурсивные операции для корня «/»;
5) --reference — взять маску прав из указанного файла;
6) -R — включить поддержку рекурсии;
7) --version — вывести версию утилиты;
8) --help — показывает справку о команде;

Вместо ключа --help, можно использовать команду man для вывода мануала.
man chmod

Теперь рассмотрим примеры использование команды на практике

Задача1:

Нужно дать владельцу право выполнения.

chmod u+x prim1
или можно воспользоваться цифровой записью
chmod 766 prim1, где prim1 — это имя файла.


Недостаток цифровой записи в том, что вы не можете модифицировать уже существующие права доступа linux. Например, используя первую команду, мы просто добавили флаг выполнения для владельца файла, а все остальные права оставили неизменными. В восьмеричном варианте мы полностью заменили текущие права новыми — все для владельца и чтение/запись для группы и остальных.
 
Задача 2:

Надо запретить чтение владельцу и оставить только чтение у других пользователей/групп

chmod 344 prim1, где prim1 — это имя файла
или
chmod u=wx-r,g=r-wx,o=r-wx



Не уверен, что это как-то нам пригодиться, но поэкспериментировать стоило.

Можно и дальше было придумывать различные комбинации и раздавать права, но давайте посмотрим возможные примеры с использованием ключей.

Задача 3:
Надо добавить запись владельцу и группе, но теперь нужно проделать эту операцию не для 1-ого файла, а для нескольких. Для этого нужно использовать ключ -R:

chmod -R ug+w kyrsach, где  kyrsach — это название репозитория



У нас было доступно только чтение у всех файлов, однако теперь попробуем добавить запись владельцу и группе. Но теперь нам надо сделать не для 1-ого файла, а для нескольких. Можно конечно вручную давать права каждому файлу, но мы использовали ключ -R.

Задача 4:

Выполнить предыдущую задачу, однако на этот раз нужно дополнительно вывести диагностику для файлов. Для этого необходимо использовать ключ -v:

chmod -Rv ug+x kyrsach



Задача 5:

Нужно изменить параметры доступа файла на чтение и запись у всех и вывести диагностику только измененного файла. Для этого нужно использовать ключ -с :

chmod -c 666 prim1, где prim1 — это имя файла



Задача 6:
Нужно изменить параметр доступа без вывода ошибок в консоль. Используйте для этого ключ -f:

chmod -f 777 666 prim1 , где prim1 -это имя файла



Если бы мы не использовали ключ -f, то нам выдало ошибку:
chmod: невозможно получить доступ к '666': Нет такого файла или каталога

Задача 7:
Нужно присвоить права доступа 1-ого файла, 2-ому файлу. Используйте для этого ключ --reference:

chmod --reference=prim1 prim2, где prim1 и prim2 являются файлами.


















Команда chown

В Linux и других UNIX-подобных операционных системах каждый пользователь имеет свои собственные файлы, причем он может регламентировать возможность доступа других пользователей к ним. Применение концепции владения файлами имеет ряд последствий, причем в некоторых случаях бывает полезно изменять владельца некоторых файлов.
Изменение владельца файла может привести к получению возможности изменения его прав доступа, а также ограничению доступа к нему другого пользователя. По этой причине обычным пользователям запрещено изменять владельцев файлов, не принадлежащих им, и только суперпользователь (root) может изменять владельцев любых файлов.


Базовый синтаксис команды выглядит следующим образом:
chown [параметры] <имя владельца:имя группы владельцев> <имя файла или директории>

Имеет следующие ключи:
1) -c, --changes — Подробно описывать действие для каждого файла, владелец которого действительно изменяется.
2) -f, --silent, --quiet — Не выдавать сообщения об ошибках для файлов, чей владелец не может быть изменён.
3) -h, --no-dereference — Работать с самими символьными ссылками, а не с файлами, на которые они указывают. Данная опция доступна только если имеется системный вызов lchown.
4) -R, --recursive — Рекурсивное изменение владельца каталогов и их содержимого.
5) -v, --verbose — Подробное описание действия (или отсутствия действия) для каждого файла.
6) --reference — использовать параметры 1-ого файла вместо параметров 2-ого файла.

Примеры использования команды chown
Задача 1:
Нужно предоставить другому пользователю возможность распоряжаться файлом по его усмотрению.
sudo chwon len prim1
где len — это имя пользователя, а prim1 — это имя файла



Задача 2:

Нужно вывести информацию во время передачи файла. Используйте команду -с :

sudo chwon -c vovka prim1 prim2
где  vovka — имя пользователя, а prim1,prim2 — название файлов


Задача 3:
Нужно передать другому пользователю/группе папку или несколько файлов. Нужно использовать ключ -R, который рекурсивно изменит владельца и группу для каталога и вложенных в неё файлов и подкаталогов:
sudo chown -Rc len:vovka kyrsach
где len — это пользователь, vovka — это группа, а kyrsach — это репозиторий
Таким образом, владельцем репозитория и файлов в нем является пользователь len, а группой остается vovka

Задача 4:
Нужно изменить владельца файла без вывода ошибок. Для этого используйте ключ -f:
chmod -f len prim4, где prim4 — файл



Если бы мы не использовали ключ -f, то нам бы выдало ошибку:
chown: невозможно получить доступ к 'prim4': Нет такого файла или каталога

Задача 5:
Нужно передать 2-ой файл владельцу, который владеет 1-ым файлом. Для этого используйте ключ --reference:
chmod --reference=prim1 prim2









