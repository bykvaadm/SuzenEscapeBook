# Работа с файлами

## Команда Ln

**Команда Ln** создает запись в директории (ссылку) с именем, целевой_файл. На целевой_файл будут установлены теже режимы, которые стоят на исходный_файл. Ссылки позволяют иметь несколько копий одного файла или каталога, размещенных в разных местах, но не занимая при этом дисковое пространство. Существует два типа ссылок, жесткие ссылки и символические ссылки. Каким образом ссылка указывает на исходный_файл, зависит от типа данной ссылки.

Команда Ln создает жесткую или символьную ссылку на каталог или файл. Проверим, так ли это.

Создадим два файла, для этого воспользуемся командой touch и воспользуемся командой  ls –l, для того что бы удостовериться, что ссылка создалась:

![file1](../img/commands/files/1.png)

В дальнейшем мы будем использовать эти файлы постоянно.

![link](../img/commands/files/2.png)

Первая команда создает жесткую ссылку **linkl**, ссылающуюся на текстовый файл **file.txt**. Вторая команда создает символическую ссылку **link2**, которая ссылается на этот же текстовый файл **file.txt**.

 
### Опции

1) **Опция –b**

Создаем резервную копию целевого файла.

Для этого возьмем файл **file1.txt** и создадим его резервную копию, с помощью команды: **ln –b file1.txt filebackup**

![ln –b file1.txt filebackup](../img/commands/files/3.png)

2) **Опция –d, -F**

Как позволить суперпользователю создать жесткие ссылки на каталоги  (операция не удастся из-за системных ограничений, даже для суперпользователя). 

Для этого воспользуемся данной опцией для создания ссылки: **ln –d –F /home/diex/practice/**

![ln –d –F /home/diex/practice/](../img/commands/files/4.png)


3) **Опция –f**

Если целевой_файл или файлы уже существуют, то перезаписать их.

Для этого запишем в файл file1.txt строчку “Hello World!” при помощи команды: **echo “Hello World!” > file1.txt**
 
и посмотрим его содержимое при помощи команды: **head file1.txt**

Далее воспользуемся нашей опцией **–f**:

![ln –f](../img/commands/files/5.png)

4) **Опция –i (--interactive)**

Спрашивать пользователя перед перезаписью файла.

Для этого имеем три файла, содержимое первого  узнаем при помощи команды: **head file1.txt**, содержимое второго файла, при помощи команды: **head file2.txt**, и содержимое третьего при помощи: **head filenew.txt.**

Далее используем опцию –i, которая спрашивает у пользователя о перезаписи: **ln –i file2.txt filenew.txt**

После проверяем, что получилось в файле file2.txt, с помощью команды: **head filenew.txt**

![ln –f](../img/commands/files/6.png)

5) **Опция –L (--logical)**

Создание ссылки на символическую ссылку

Создадим символьную ссылку на file1.txt, с помощью команды: **ln --symbolic file1.txt link1**

Далее создадим ссылку на символьную ссылку, используя опцию -L: **ln --logical link1 link2**

Далее проверим, куда указывает link2, при помощи команды: **head link2**

![ln –f](../img/commands/files/7.png)
 
## Команда locate

Если команда **find** выполняется слишком долго, то можно попробовать воспользоваться командой **locate**. Команда **locate** выполняет поиск по всей файловой системе примерно, как и команда **find**, однако поиск ведётся по базе данных, а не по самой файловой системе, что обуславливает её быстроту. Данный подход имеет массу преимуществ, но он не лишён и недостатков. Основной его недостаток заключается в том, что после создания каждого нового файла или новой директории для корректной работы утилиты приходится обновлять информацию в базе данных. В противном случае утилита не сможет найти файлы и директории, созданные после последнего обновления информации в базе данных. Обновление базы данных выполняется автоматически каждое утро, чтобы у вас был всегда более свежий список файлов своей системы. Также процесс обновления можно запустить вручную, при помощи **updated**. Перед этим необходимо получить *root-права*, с помощью команды **su**.

### Опции команды locate

* **-n** - Ограничение количества возвращаемых результатов
* **-c** - Поиск числа найденных файлов
* **-i** - Поиск без учета регистра
* **-e** - Отображение только файлов, существующих в системе
* **-0** - Вывод записей без символа «новая строка»
* **-S** - Обзор вашей локальной базы данных locate
* **-q** - Подавление сообщений об ошибках
* **-d** - Выбор другого расположения mlocate
* **-b** - Игнорирование пути до файла при поиске

### Использование команды locate

Для того чтобы найти конкретные файлы в системе, всё что вам необходимо сделать, так это передать команде locate имя файла, который необходимо найти. (Также файлы можно найти при помощи регулярных выражений, например, «**locate –r /test_1$**».)

Заранее я создал два файла с именами «**test_1**» и «**mork_file_1**». Давайте попробуем их найти при помощи команды locate.

Для начала я вхожу под root-правами, далее обновляю список файлов в файловой системе и наконец при помощи команды locate нахожу нужные мне файлы. Также, если вы хотите найти все файлы в именах которых содержится определённая строка, то вы можете сделать это следующим образом: 

![locate](../img/commands/files/23.png)

*Например*, мне нужно найти все файлы где присутствует строка «**mork**». Для этого нужно с обеих сторон поставить \*.

Для того чтобы вместо имён найденных файлов с их полными и абсолютными путями утилита *locate* выводила лишь информацию о количестве найденных файлов и директорий, можно воспользоваться параметром –с.

![locate](../img/commands/files/24.png) 

Как стало видно я воспользовался данным параметром и обнаружил, что количество найденных файлов, в которых присутствует строка «**mork**» 2 штуки.

Далее затрагивается проблема о выводе информации лишь о существующих в данный момент файлах. Для наглядности я удалю файл, созданный ранее «**test_1**». Для того чтобы проверить действительно ли это так воспользуемся командой **find**, а затем **locate**.

![locate](../img/commands/files/25.png) 

Как видим команда **find** не может найти данный файл, а утилита **locate** спокойно нам демонстрирует в какой директории этот файл находится. 
Для того чтобы это исправить, можно воспользоваться параметром –e.

Как видим теперь утилита locate показывает, что такого файла в системе нет.

Далее рассмотрим параметр – i, при помощи которого locate будет игнорировать регистр символов имен файлов. Для наглядности я создам два файла с именами «math_geom» и «MATH_GEOM».

![locate](../img/commands/files/26.png)

Как видно из примера, если не использовать параметр –i то утилита locate находит только один файл, а если использовать, то два, невзирая на регистр имён.
Если вам необходима информация об используемой утилитой locate базе данных, а также статистических данных, касающихся этой базы данных, вы можете воспользоваться параметром –S.

## Команда whereis

Данная команда используется для того, чтобы определить в каком каталоге расположена искомая команда, её исходный код и соответствующая страница документации. В отличие от find или locate, здесь вам потребуется точное знание названия команды. К недостаткам команды whereis можно отнести то, что она просматривает только каталоги, включенные в специальный список. По этой причине она не сможет найти новую команду или страницу руководства, которую вы только что инсталлировали.

### Опции команды whereis

* **-b** - Искать путь только к исходным файлам;
* **-m** - Искать путь только к документации;
* **-s** - Искать путь только к источникам;
* **-u** - Поиск необычных записей;
* **-B** - Ограничение поиска исходных файлов;
* **-M** - Ограничение поиска руководств;
* **-S** - Ограничение поиска источника;
* **-f** - Сообщение о начале имен файлов;
* **-v** - Показать информацию о версии;
* **-h** - Показать подсказки.
  
\*Файл считается необычным, если у него нет ни одной записи запрошенного типа

### Использование команды whereis

*Например*, если вы хотите узнать, где содержится определённая команда Unix, в данном случае команда sudo, то стоит воспользоваться whereis <название команды>

![ln –f](../img/commands/files/8.png)

В основном команду whereis используют для нахождения только исполняемых файлов команд. И для удобства пользования существует специальная опция –b.

Если вы хотите выполнить поиск исполняемого файла по пути, отличному от пути по – умолчанию, заданному whereis, то вы можете использовать опцию -B и указать путь в качестве аргумента. (Изменение или иное ограничение мест, где whereis ищет исходные файлы)

Также команда whereis ищет программы среди стандартных директорий. Для наглядности я установил программу Midnight Commander, посмотрим, что нам даст вызов whereis.

## Команда find

**Find** — это одна из наиболее важных и часто используемых утилит системы Linux. Это команда для поиска файлов и каталогов на основе специальных условий. Ее можно использовать в различных обстоятельствах, например, для поиска файлов по разрешениям, владельцам, группам, типу, размеру и другим подобным критериям.

Утилита **find** предустановлена по умолчанию во всех Linux дистрибутивах, поэтому нам не нужно будет устанавливать никаких дополнительных пакетов. Это очень важная находка для тех, кто хочет использовать командную строку наиболее эффективно.

Команда find имеет такой синтаксис: **find [папка] [параметры] критерий шаблон [действие]**

**Папка** — каталог в котором будем искать

**Параметры** — дополнительные параметры, например, глубина поиска, и  т .д.

**Критерий** — по какому критерию будем искать: имя, дата создания, права, владелец и т д.

**Шаблон** — непосредственно значение, по которому будем отбирать файлы.

### Основные параметры команды find.

Есть очень много  параметров, и я решила рассмотреть только самые полезные.

* **-P** -  никогда не открывать символические ссылки
* **-L** -  получает информацию о файлах по символическим ссылкам. Важно для дальнейшей обработки, чтобы обрабатывалась не ссылка, а сам файл.
* **-maxdepth** — максимальная глубина поиска по подкаталогам, для поиска только в текущем каталоге установите 1.
* **-depth** — искать сначала в текущем каталоге, а потом в подкаталогах
* **-mount** -  искать файлы только в этой файловой системе.
* **-version** — показать версию утилиты find
* **-print** — выводить полные имена файлов
* **-type f** — искать только файлы
* **-type d** — поиск папки в Linux


### Критерии:

Критериев у команды find в Linux очень много, и я опять же продемонстрирую только основные.

* **-name** — поиск файлов по имени
* **-perm** — поиск файлов в Linux по режиму доступа
* **-user** — поиск файлов по владельцу
* **-group** — поиск по группе
* **-mtime** — поиск по времени модификации файла
* **-atime** — поиск файлов по дате последнего чтения
* **-nogroup** — поиск файлов, не принадлежащих ни одной группе
* **-nouser** — поиск файлов без владельцев
* **-newer** — найти файлы новее чем указанный
* **-size** — поиск файлов в Linux по их размеру


### Примеры использования команды find:

**Найти файл**

Показать все существующие файлы в директории:

![find -L](../img/commands/files/9.png)

**Найти файл в определенной папке:**

Показать все файлы в указанной директории:

![find -L](../img/commands/files/10.png)

Искать файлы по имени в текущей папке:

![find -L](../img/commands/files/11.png)

* ~ - домашняя папка пользователя в качестве начального пути для поиска
* -name - поиск по имени файла

Так же можно делать поиск по части имени

* find ~ -name 'cat.\*'
* find ~ -name '\*.doc'

У параметра name есть альтернатива iname — игнорирование регистра символов.

```
 find ~ -name '*.png'
```

**Найти файл с ограничением глубины поиска:**

Команда find также позволяет ограничить глубину поиска файлов определенным количеством поддиректорий. Для этого предназначен параметр -maxdepth.

*Например*, предположим, что имеется следующая структура директорий:

```
find . -maxdepth 3 -name "*.png"
```

![find](../img/commands/files/12.png)

**Инвертирование шаблона:**

Найти файлы, которые не соответствуют шаблону:

```
find . -not -name "test*"
```
![find](../img/commands/files/13.png)

**Найти файл с несколькими критериями:**

Поиск командой find в Linux по нескольким критериям, с оператором исключения:

```
 find . -name "test" -not -name "*.png" 
```

![find](../img/commands/files/14.png)

**Найти файл с несколькими каталогами:**

Искать в двух каталогах одновременно:

```
find ./test ./test2 -type f -name "*.png"
```

![find](../img/commands/files/15.png)

**Найти скрытые файлы:**

Найти скрытые файлы:

```
 find ~ -type f -name ".*"
```

![find](../img/commands/files/16.png)

## LVM

**LVM** или **Logical Volume Manager** — это еще один программный уровень абстракции над физическими разделами жесткого диска, который позволяет создавать логические тома для хранения данных без непосредственной переразметки жесткого диска на одном или нескольких жестких дисках. LVM увеличивает удобство работы с жестким диском, аппаратные особенности работы скрываются программным обеспечением, поэтому вы можете изменять размеры дисков, перемещать их на лету, без остановки приложений или размонтирования файловых систем. Это очень удобно на серверах, вы можете добавить еще один диск или расширить существующие lvm тома на лету.
  
**LVM** работает на уровне ядра, поэтому гарантируется максимальная прозрачность настройки и использования дисков. Программы смогут работать с логическими, виртуальными lvm разделами, точно так же, как и с обычными.

Вот преимущества использования LVM перед обычными разделами жесткого диска.

* **Легкое изменение размера** — вы можете расширить или уменьшить lvm раздел без переформатирования диска
* **Легкая расширяемость пространства** — вы можете увеличить доступное пространство, просто добавляя новые физические диски в общий пул памяти LVM, таким образом, вы получаете большую гибкость.
* **Резервное копирование и зеркалирование данных** — возможность записи на несколько дисков одновременно позволяет увеличить производительность работы системы, а также есть возможность настроить зеркалирование данных и резервное копирование разделов для увеличения безопасности.
* **Читаемые имена** — вы можете давать любые имена вашим логическим разделам, так чтобы они соответствовали назначению раздела и легко запоминались.

А сейчас я продемонстрирую создание LVM, настройку и работу с дисками. 

### Создание LVM LINUX:

Есть 3 уровня абстракции:

* **PV (Physical Volume)** — физические тома (это могут быть разделы или целые «неразбитые» диски)
* **VG (Volume Group)** — группа томов (объединяем физические тома (PV) в группу, создаём единый диск, который будем дальше разбивать так, как нам хочется)
* **LV (Logical Volume)**  — логические разделы, собственно раздел нашего нового «единого диска» Группы Томов, который мы потом форматируем и используем как обычный раздел, обычного жёсткого диска.

Перед тем как начинать создание lvm linux необходимо установить нужные для этого инструменты:

Соответственно структуре LVM, нам нужно будет инициализировать физические разделы для LVM, объединить их в группу, а затем создать из этой группы нужные нам логические тома.

### Инициализация физических LVM разделов:

Сначала определимся с томами, которые будем использовать, допустим, это будут /dev/sda6 и /dev/sda7. Инициализировать их для работы LVM можно с помощью команды pvcreate:

Чтобы посмотреть действительно ли были созданы физические тома LVM то, нужно использовать команду pvcsan:

Также можно посмотреть физические LVM разделы с более подробными атрибутами, такими как размер, общий размер, физический размер, свободное место и т д:

**PE Size** — это размер одного блока LVM, по умолчанию он равен четырем мегабайтам, но это значение можно изменить.

### Создание группы разделов LVM:

**Группа томов** — это не что иное, как пул памяти, который будет распределен между логическими томами и может состоять из нескольких физических разделов. После того как физические разделы инициализированы, то можете создать из них группу томов (Volume Group, VG):


С помощью lvm команды vgdisplay можно посмотреть созданные группы томов:

### Создание логических томов LVM:

Теперь все готово, чтобы создать логические LVM разделы. Для этого буду использовать команду lvcreate и создам логический раздел размером 80 Мегабайт, или 20 блоков LVM:

Посмотреть список доступных логических разделов LVM можно по аналогии с предыдущими разделами с помощью команды lvdisplay:

Теперь, когда раздел создан, можно работать с ним как и с обычным разделом. Например, отформатируем его в файловую систему ext4, а затем примонтирую в /mnt:

Как видите, монтирование lvm linux ничем не отличается от монтирования обычных разделов.

Вообще говоря, lvm разделы могут быть трех типов:

* Линейные разделы (linear volume)
* Полосные разделы (Striped Volume)
* Зеркалированные разделы (Mirrored Volume)

**Линейные разделы** — это обычные LVM тома, они могут быть созданы как их одного, так и нескольких физических дисков. Например, если у вас есть два диска по 2 гигабайта, то вы можете их объединить и в результате получите один раздел LVM linux, размером 4 гигабайта. По умолчанию используются именно линейные LVM разделы.

Полосные разделы очень полезны при больших нагрузках на жесткий диск. Здесь вы можете настроить одновременную запись на разные физические устройства, для одновременных операций, это может очень сильно увеличить производительность работы системы.

Для этого нужно задать количество полос записи с помощью опции -i, а также размер полосы опцией -l. Количество полос не должно превышать количества физических дисков. Например:

Зеркалированный том позволяет записывать данные одновременно на два устройства. Когда данные пишутся на один диск, они сразу же копируются на другой. Это позволяет защититься от сбоев одного из дисков. Если один из дисков испортится, то разделы LVM просто станут линейными и все данные по-прежнему будут доступны. 

Для создания такого раздела LVM Linux можно использовать команду:

### Удалить LVM раздел:

Вы можете не только настроить lvm тома изменяя их размер и атрибуты, но и удалить lvm раздел, если он вам больше не нужен. Это делается с помощью lvm команды lvremove:

Теперь лишний раздел удален.

### Изменение размера LVM тома:

Вы можете изменять уже созданные разделы LVM увеличивая или уменьшая их размер. Причем неважно есть ли место на физическом диске после этого раздела, если в пуле есть память, вы можете ее использовать для любого раздела. Чтобы изменить размер lvm нужно использовать команду lvextend. 

*Например*, lvm увеличим размер диска из 80 до 100 мегабайт:

Также можем увеличить размер lvm, использовав знак +:

Точно так же можно выполнить уменьшение lvm раздела с помощью знака -.

## Команда diff

Для сравнения двух или нескольких файлов в Linux есть команда diff. Она может сравнивать как отдельные файлы, так и каталоги. Рассмотрим синтаксис, опции команды diff и несколько примеров использования.

**Сравнить два файла**

Для начала рассмотрим содержимое двух файлов, при помощи команды head:

Первый файл:

Второй файл:

Далее сравним  файлы:

![diff](../img/commands/files/17.png)

Несложно заметить, что вывод в данном формате плохо читается, так как предназначен для программной обработки. Служебные метки имеют формат [номер строки или диапазон строк первого файла][действие][номер строки или диапазон строк второго файла]. Для описания действий используются буквенные символы, а именно, a — добавление, c — изменение и d — удаление. В данном случае метка 1,2d0 обозначает, что строки с первой по вторую должны быть удалены из начала первого файла, а метка 3a2,6 — что после третьей строки в первый файл должны быть добавлены строки со второй по шестую из второго файла. Добавляемые и удаляемые строки обозначаются с помощью символов > и < соответственно.

### Опции

1.. Опция –q

Производит вывод только тогда, когда файлы отличаются, если нет различия, то ничего не выводит.

---

Сравним два файла, с помощью команды head узнаем содержимое этих файлов:

Первый файл: 

```
head file1.txt
```

Второй файл:

```
head file2.txt
``` 

Сравним два файла с опцией -q:

```
diff –q file1.txt file2.txt 
```

![diff](../img/commands/files/18.png)

2.. Опция –c

**Копируемый контекст вывода**

Сравним файлы, используя опцию –с:

![diff](../img/commands/files/19.png)

3.. Опция –u

**Унифицированный контекстный вывод**

Сравним файлы, используя опцию –u:

![diff](../img/commands/files/20.png)

В случае использования этого формата вывода символы "+" и "-" перед строками соответствуют различиям в файлах: с помощью символа "-" маркируются строки из файла с именем file1, отсутствующие в файле с именем file2.txt, а с помощью символа "+" - строки из файла с именем file2, которые должны быть добавлены в файл с именем file1.txt.

4.. Опция –N

**Обработка отсутствующих файлов как пустых**

Утилита diff также поддерживает параметр, с помощью которого вы можете сообщить ей о том, что следует рассматривать отсутствующие файлы как пустые. Если вы сравните файлы с именами file1 и file3 (причем последнего файла не существует), по умолчанию diff выведет сообщение об ошибке:

![diff](../img/commands/files/21.png)

В этом нет ничего плохого; по сути, данное поведение является вполне обоснованным. Но бывают случаи, когда необходимо избежать вывода сообщений об ошибках (возможно, при использовании diff в рамках сценариев командной оболочки), в которых вы можете воспользоваться параметром -N для обработки отсутствующих файлов как пустых и продолжения сравнения файлов.

### Команда chmod

Команда chmod представляет из себя удобный инструмент для повешения безопасности ОС и позволяет назначить права доступа к файлам или каталогам.

Если ты суперпользователь, то можешь спокойно изменять права доступа у любого файла и каталога, которые могут принадлежать любому пользователю системы.

Если ты обычный юзер, то ты можешь изменять только созданные тобой файлы и каталоги.

Для того чтоб настраивать права, нам понадобиться знать следующие виды прав:

* **r** — чтение;
* **w** — запись;
* **x** — выполнение;
* **s** — выполнение от имени суперпользователя;

Так же есть категория пользователей, для которых мы и устанавливаем эти права:

* **u** — владелец файла;
* **g** — группа файла;
* **o** — все остальные пользователи;

Синтаксис настройки прав следующий -

группа_пользователейдейстивевид_прав

Действием могут быть как + (включать) так и — (отключать)

*Примеры:*

* **u+x** — разрешить выполнение для владельца;
* **ugo+x** — разрешить выполнение для всех;
* **o-x** — запретить выполнение для остальных пользователей;
* **ugo+rwx** — разрешить все для всех;

Так же права можно записывать другим способом. Есть восьмеричный формат записи, он сложнее в понимании, но пишется легче и короче.

* **0** — никаких прав;
* **1** — только выполнение;
* **2** — только запись;
* **3** — выполнение и запись;
* **4** — только чтение;
* **5** — чтение и выполнение;
* **6** — чтение и запись;
* **7** — чтение, запись и выполнение;

Права на папку или файл устанавливается следующим образом. Первой цифрой указывается права для владельца, затем для группы, а потом для остальных. 

*Пример:*

* **744** — разрешить все для владельца, а остальным только чтение;
* **777** — всем все разрешено;

Так же параметры можно указывать следующим образом:

* u=rwx
* g=rw-x
* o=---

Это дольше писать, чем 750, но куда эффективнее воспринимается новичками в изучении ограничения доступа к файлам.


Теперь рассмотрим колючи команды:

* **-c** — выводить информацию обо всех изменения;
* **-f** — не выводить сообщение об ошибках;
* **-v** — выводит диагностику для каждого обработанного файла
* **--preserve-root** — не выполнять рекурсивные операции для корня «/»;
* **--reference** — взять маску прав из указанного файла;
* **-R** — включить поддержку рекурсии;
* **--version** — вывести версию утилиты;
* **--help** — показывает справку о команде;

Вместо ключа --help, можно использовать команду man для вывода мануала.
man chmod

Теперь рассмотрим примеры использование команды на практике

**Нужно дать владельцу право выполнения.**

`chmod u+x prim1`

или можно воспользоваться цифровой записью

`chmod 766 prim1, где prim1 — это имя файла.`


Недостаток цифровой записи в том, что вы не можете модифицировать уже существующие права доступа linux. Например, используя первую команду, мы просто добавили флаг выполнения для владельца файла, а все остальные права оставили неизменными. В восьмеричном варианте мы полностью заменили текущие права новыми — все для владельца и чтение/запись для группы и остальных.
 
**Надо запретить чтение владельцу и оставить только чтение у других пользователей/групп**

`chmod 344 prim1, где prim1 — это имя файла`

или

`chmod u=wx-r,g=r-wx,o=r-wx`

Не уверен, что это как-то нам пригодиться, но поэкспериментировать стоило.

Можно и дальше было придумывать различные комбинации и раздавать права, но давайте посмотрим возможные примеры с использованием ключей.

**Надо добавить запись владельцу и группе, но теперь нужно проделать эту операцию не для 1-ого файла, а для нескольких. Для этого нужно использовать ключ -R:**

`chmod -R ug+w kyrsach`, где  kyrsach — это название репозитория

У нас было доступно только чтение у всех файлов, однако теперь попробуем добавить запись владельцу и группе. Но теперь нам надо сделать не для 1-ого файла, а для нескольких. Можно конечно вручную давать права каждому файлу, но мы использовали ключ -R.

**Выполнить предыдущую задачу, однако на этот раз нужно дополнительно вывести диагностику для файлов. Для этого необходимо использовать ключ -v:**

```
chmod -Rv ug+x kyrsach
```

**Нужно изменить параметры доступа файла на чтение и запись у всех и вывести диагностику только измененного файла. Для этого нужно использовать ключ -с :**

```
chmod -c 666 prim1, где prim1 — это имя файла
```

Нужно изменить параметр доступа без вывода ошибок в консоль. Используйте для этого ключ -f:

```
chmod -f 777 666 prim1 , где prim1 -это имя файла
```
Если бы мы не использовали ключ -f, то нам выдало ошибку:

```
chmod: невозможно получить доступ к '666': Нет такого файла или каталога
```

Нужно присвоить права доступа 1-ого файла, 2-ому файлу. Используйте для этого ключ --reference:

```
chmod --reference=prim1 prim2, где prim1 и prim2 являются файлами.
```

## Команда chown

В Linux и других UNIX-подобных операционных системах каждый пользователь имеет свои собственные файлы, причем он может регламентировать возможность доступа других пользователей к ним. Применение концепции владения файлами имеет ряд последствий, причем в некоторых случаях бывает полезно изменять владельца некоторых файлов.

Изменение владельца файла может привести к получению возможности изменения его прав доступа, а также ограничению доступа к нему другого пользователя. По этой причине обычным пользователям запрещено изменять владельцев файлов, не принадлежащих им, и только суперпользователь (root) может изменять владельцев любых файлов.

Базовый синтаксис команды выглядит следующим образом:

```
chown [параметры] <имя владельца:имя группы владельцев> <имя файла или директории>
```

Имеет следующие ключи:

* **-c**, **--changes** — Подробно описывать действие для каждого файла, владелец которого действительно изменяется.
* **-f**, **--silent**, --quiet — Не выдавать сообщения об ошибках для файлов, чей владелец не может быть изменён.
* **-h**, **--no-dereference** — Работать с самими символьными ссылками, а не с файлами, на которые они указывают. Данная опция доступна только если имеется системный вызов lchown.
* **-R**, **--recursive** — Рекурсивное изменение владельца каталогов и их содержимого.
* **-v**, **--verbose** — Подробное описание действия (или отсутствия действия) для каждого файла.
* **--reference** — использовать параметры 1-ого файла вместо параметров 2-ого файла.

### Примеры использования команды chown

**Нужно предоставить другому пользователю возможность распоряжаться файлом по его усмотрению.**

```
sudo chwon len prim1
```

где len — это имя пользователя, а prim1 — это имя файла

**Нужно вывести информацию во время передачи файла. Используйте команду -с**:

```
sudo chwon -c vovka prim1 prim2
```

где  vovka — имя пользователя, а prim1,prim2 — название файлов

**Нужно передать другому пользователю/группе папку или несколько файлов. Нужно использовать ключ -R, который рекурсивно изменит владельца и группу для каталога и вложенных в неё файлов и подкаталогов:**

```
sudo chown -Rc len:vovka kyrsach
```

где len — это пользователь, vovka — это группа, а kyrsach — это репозиторий

Таким образом, владельцем репозитория и файлов в нем является пользователь len, а группой остается vovka


**Нужно изменить владельца файла без вывода ошибок. Для этого используйте ключ -f:**

```
chmod -f len prim4, где prim4 — файл
```
Если бы мы не использовали ключ -f, то нам бы выдало ошибку:

```
chown: невозможно получить доступ к 'prim4': Нет такого файла или каталога
```

**Нужно передать 2-ой файл владельцу, который владеет 1-ым файлом. Для этого используйте ключ --reference:**

```
chmod --reference=prim1 prim2
```