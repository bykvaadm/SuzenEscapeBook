# Введение
## Цель работы
Познакомиться с оболочкой bash и утилитами, используемыми IT–специалистом в повседневной жизни.

В данной курсовой работе мы познакомимся с фильтрами, которые позволяют строить сложные конвейеры для манипуляций с текстом. 
Мы узнаем, как выводить текст, сортировать его, выполнять подсчет слов и строк, преобразовывать символы, а также многое другое.  

Фильтрация текста – это процесс получения входного текстового потока, выполнения неких преобразований над ним и передача
измененных данных в выходной поток. Хотя входные или выходные данные могут поступать из файлов, в UNIX® и Linux фильтрация обычно осуществляется путем составления конвейеров из команд, в которых вывод одной команды передается по программному каналу
(или перенаправляется) на вход следующей команде.

В рамках данной курсовой работы представлена информация о наиболее часто используемых фильтрах. В результате комбинирования простых команд и фильтров с использованием программных каналов могут быть созданы элегантные решения.

К числу команд-фильтров относятся `grep`, `ack`, `awk`, `sort`, `uniq`, `ws`, `tr`. Далее рассмотрим их более подробно.

## 1. Создание файлов
1. Переходим в директорию рабочего стола
2. Создаем папку `kyrsovay2018`
3. Переходим в созданную директорию
4. Создаем файл `tanya.txt` в данной директории
5. Заносим данные в файл
6. Создаем файл `ksenya.txt` в данной директории
7. Заносим данные в файл

**тут картинка**

В курсовой работе используются не только два файла. Эти файлы приведены в качестве примера.

# 2. grep
Команда `grep`, одна из самых известных и употребительных команд Unix-подобных ОС, ведет свое начало от первого текстового Unix-редактора - `ed`. В этом редакторе была команда **g/re/p (global/regular expression/print)**, которая и дала свое название новой программе.

Утилита `grep` осуществляет во входных данных поиск строк, совпадающих с данным выражением (данными выражениями). Если строка ввода совпадает с любым из выражений, она считается "выбранной". По умолчанию выбранные строки записываются в стандартный поток вывода. 

Утилита `grep` распознает три типа регулярных выражений: базовые, расширенные и фиксированные.

Базовые и расширенные регулярные выражения аналогичны арифметическим выражениям, в которых крупные выражения формируются путем объединения более мелких выражений и операторов по установленному правилу приоритетов. В регулярных выражениях присутствует "невидимый" оператор, т.е. конкатенация. Конкатенация двух выражений означает сопоставление лево, а затем правой части. Наименьшим выражением является один символ. 

### Задача
Команда `grep` может обрабатывать любое количество файлов одновременно. Возьмем два исходных файла, которые мы создали. 
### Команда:
```bash
grep '5' tanya.txt ksenya.txt
```
### Результат:
**тут картинка**

В выводе перечислены файлы, и указано, в каком из них какая строка содержит символ «5». Символ пришлось взять в кавычки, чтобы командный интерпретатор понял, что имеется в виду символ, а не условный знак. Команда `grep` вовсе не ограничена одним выражением, можно задавать хоть целые фразы. Только их тоже нужно заключать в кавычки (одинарные или двойные).

### Команда
```bash
grep 'e f' tanya.txt ksenya.txt
```
### Результат
**тут картинка**

# Опции grep
## 1. Опция -i (--ignore-case)
### Задача
Приказывает команде игнорировать регистр символов, таким образом, поиск будет производиться как среди заглавных, так и среди строчных букв.
### Команда
```bash
grep -i 'w' tanya.txt ksenya.txt
```
### Результат
**тут картинка**
Изначально была задана строчная буква **'w'**, а на экран произошел вывод как строчных, так и заглавных букв **'w'**
## 2. Опция -c (--count)
### Задача
Эта опция не выводит строки, а подсчитывает количество строк, в которых обнаружена заданная конфигурация символов.
### Команда
```bash
grep -c 'a' tanya.txt ksenya.txt
```
### Результат
**тут картинка**

То есть в двух строках файла tanya.txt и трех строках файла ksenya.txt встречается сочетание символа **«а»**.

## 3. Опция -n (--line-number)
### Задача
При использовании этой опции вывод команды `grep` будет указывать номера строк, содержащих заданную конфигурацию.
### Команда
```bash
grep -n 'ou' tanya.txt ksenya.txt
```
### Результат
**тут картинка**

Во второй и четвертой строках файла tanya.txt найдено сочетание **'ou'**

## 4. Опция -v (--invert-match)
### Задача
Выполняет работу, обратную обычной - выводит строки, в которых заданная конфигурация не встречается.
### Команда
```bash
grep -v 'ewq' tanya.txt ksenya.txt
```
### Результат
**тут картинка**

Во всех строках, которые выведены на экран, нет конфигурации символов **'ewq'**.

## 5. Опция -w (--word-regexp)
### Задача
Заставит команду `grep` искать только строки, содержащие все слово или фразу, составляющую данную конфигурацию.
### Команда
```bash
grep -w 'ar' tanya.txt ksenya.txt
```
### Результат
**тут картинка**

Вывода нет, то есть не нашлись строки, содержащих выражение **"ar"**. 
А вот в данном случае:
**тут картинка**  
Команда находит точное соответствие в файле ksenia.txt.

## 6. Опция -x (--line-regexp)
### Задача
Еще более строгая команда. Она отберет только те строки исследуемого файла или файлов, которые полностью совпадают с заданной конфигурацией.
### Команда
```bash
grep -x 'Woy' tanya.txt ksenya.txt
```
### Результат
**тут картинка**  
Строгое совпадение нашлось только в файле ksenya.txt. Это строка **'Woy'**

## 7. Опция -l (--files-with-matches)
### Задача
Команда `grep` с этой опцией не возвращает строки, содержащие заданную конфигурацию, а сообщает лишь имена файлов, в которых данный образец найден.
### Команда
```bash
grep -l 'Tanya' tanya.txt ksenya.txt
```
### Результат
**тут картинка**  
Конфигурация символов ‘Tanya’ была найдена только в файле tanya.txt. Стоит отметить, что сканирование каждого из заданных файлов продолжается только до первого совпадения с заданной конфигурацией.

## 8. Опция -L (--files-without-match)
### Задача
Эта команда наоборот, сообщает имена тех файлов, где не встретилась заданная конфигурация.
### Команда
```bash
grep -L 'Tanya' tanya.txt ksenya.txt
```
### Результат
**тут картинка**  
Конфигурация символов **'Tanya'** была не найдена только в файле ksenya.txt

Команда `grep` настолько полезна, многофункциональна и проста в употреблении, что, однажды познакомившись с ней, невозможно представить себе работы без нее. 

# 3. ack
Инструмент ack был разработан специально для поиска исходного кода программ. Потому ack ищет определенные файлы и игнорирует другие.

К примеру, при поиске структуры каталогов проекта иерархия репозитория системы управления версиями, как правило, не нужна. Она содержит информацию о более старых версиях файла и, скорее всего, приведет к многочисленным повторам. Ack понимает, что здесь искать не нужно, поэтому он игнорирует эти каталоги, благодаря чему результат получается более сжатым и содержит меньше ошибочных данных.

Подобным образом он игнорирует общие резервные файлы, созданные некоторыми текстовыми редакторами. Также нет смысла искать с помощью ack некоторые файлы, которые обычно встречаются в исходных каталогах: сжатые версии веб-файлов, изображения, PDF-файлы и т.д. Все эти функции положительно влияют на результаты почти каждого поиска.     Кроме того, эти настройки всегда можно изменить.

Для начала нужно установить инструмент ack на сервер. На сервере Ubuntu или Debian это так же просто, как установить утилиту из репозитория по умолчанию. Пакет называется `ack-grep`:
```bash
sudo apt update
sudo apt install ack-grep
```
Поскольку исполняемый файл также называется `ack-grep`, можно сказать системе сократить его имя до `ack`, чтобы использовать его в командной строке, введя следующую команду:
```bash
dpkg-divert --local --divert /usr/bin/ack --rename --add /usr/bin/ack-grep
```
Теперь инструмент будет отвечать на имя `ack` вместо `ack-grep`. 

### Задача
Вывести файлы в которых был найден указанный шаблон.
### Команда
```bash
ack w
```
### Результат
**тут картинка** 
Данная команда нашла все файлы, в которых встречается шаблон **'w'**.

# Опции ack
## 1. Опция -f
### Задача
Узнать количество файлов в директории, в которой мы сейчас находимся.
### Команда
```bash
ack -f | wc -l
```
### Результат
**тут картинка**
В данной директории было найдено 4 файла.

## 2. Опция -w
### Задача
Найти файлы, в которых слова четко совпадают с границами шаблона. 
### Команда
```bash
ack -w We
```
### Результат
**тут картинка**
Точное совпадение нашлось только в файле `tanya.txt`.

## 3. Опция -ch
### Задача
Узнать общее количество найденных совпадений с шаблоном в файлах.
### Команда
```bash
ack -ch a
```
### Результат
**тут картинка**  
В файлах, данной директории, нашлось 19 совпадений указанного шаблона **'a'**.

## 4. Опция -c
### Задача
Узнать количество совпадений с шаблоном в каждом файле.
### Команда
```bash
ack -c a
```
### Результат
**тут картинка**  
Шаблон “а” был встречен в файле `ksenya.txt` 5 раз, в файле `povtor.txt` 0 раз , в файлах `dolgi.txt` и `tanya.txt` по 7 раз.


# 4. awk
Утилита `awk`, или точнее `GNU awk`, в сравнении с `sed`, выводит обработку потоков данных на более высокий уровень. Благодаря awk в нашем распоряжении оказывается язык программирования, а не довольно скромный набор команд, отдаваемых редактору. С помощью языка программирования `awk` можно выполнять следующие действия:
- объявлять переменные для хранения данных;
- использовать арифметические и строковые операторы для работы с данными;
- использовать структурные элементы и управляющие конструкции языка, такие, как оператор `if-then` и циклы, что позволяет реализовать сложные алгоритмы обработки данных;
- создавать форматированные отчёты.

Если говорить лишь о возможности создавать форматированные отчёты, которые удобно читать и анализировать, то это оказывается очень кстати при работе с лог-файлами, которые могут содержать миллионы записей. Но `awk` — это намного больше, чем средство подготовки отчётов.
Схема вызова `awk` выглядит так:
```bash
awk options program file
```
`Awk` воспринимает поступающие к нему данные в виде набора записей. Записи представляют собой наборы полей. Упрощенно, если не учитывать возможности настройки `awk` и говорить о некоем вполне обычном тексте, строки которого разделены символами перевода строки, запись — это строка. Поле — это слово в строке.

Одна из основных функций `awk` заключается в возможности манипулировать данными в текстовых файлах. Делается это путём автоматического назначения переменной каждому элементу в строке. По умолчанию `awk` назначает следующие переменные каждому полю данных, обнаруженному им в записи:
```
$0 — представляет всю строку текста (запись).
$1 — первое поле.
$2 — второе поле.
$n — n-ное поле.
```

Поля выделяются из текста с использованием символа-разделителя. По умолчанию — это пробельные символы вроде пробела или символа табуляции.

Рассмотрим использование этих переменных на простом примере. А именно, обработаем файл, в котором содержится несколько строк.

### Задача
Вывести только первый столбец в указанном файле. Где разделителем столбцов по умолчанию считается пробел. 
### Команда
```bash
awk '{print $1}' ksenya.txt
```
### Результат
**тут картинка**  
Данная команда вывела первые слова (первые поля) каждой записи, содержащиеся в файле `ksenya.txt`.

# Опции awk
## 1. Опция -F
### Задача
Вывести поля, в которых используется указанный в команде разделитель. Текст файла text.txt:
```
Hello, my name is Ksenya.
My friends is Tanya, Lina, Julia, Poly.
```
В качестве разделителя зададим символ **','**.
### Команда
```bash
awk -F, '{print $1}' text.txt
```
### Результат
**тут картинка**  
Данная команда вывела первые поля файла `text.txt`, считая в качестве символа разделителя (конца поля) символ **','**.

## 2. Опция -v
### Задача
Передать в программу переменную, а именно константу.
### Команда
```bash
awk -v pi=3.1415 '{print $1}'
```
### Результат
**тут картинка**  
В результате работы команды было выведено число, занесённое нами в константу.

## 3. Опция -f
### Задача
Использовать скрипты, хранящиеся в файлах, и обратиться к ним в команде.
Подготовим файл text1.txt, в который запишем следующее содержимое:
```
{print $1 "*" $2}
```
Вызовем awk, указав этот файл в качестве источника команд
### Команда
```bash
awk -F, -f text1.txt text.txt'
```
### Результат
**тут картинка**  
В качестве разделителя строк мы указали символ **','**. Поэтому в ходе выполнения команды, между первым и вторым полем разделитель поменялся на символ **'*'**, который мы указали в файле источника команд `text1.txt`.

## 4. length
### Задача
Получить длину каждой строки, использую ключ `length`.
### Команда
```bash
awk '{print length}' text.txt'
```
### Результат
**тут картинка**  
В файле text.txt, в первом предложении количество символов **25**, во втором **39**.

## 4. BEGIN/END
### Задача
Вывести перед файлом и после него указанные данные.
### Команда
```bash
awk 'BEGIN {print "--------------------"} {print $0} END {print "BYE"}' text.txt'
```
### Результат
**тут картинка**  
В результате выполнения данной команды, в начало и конец файла `text.txt`, который мы выводим полностью (указав `$0`), будут добавлены строки указанные в команде.

`awk` - это мощнейший инструмент обработки данных, масштабы которого сопоставимы с отдельным языком программирования.

# 5. sort
Команда `sort` сортирует содержимое файла в алфавитном или нумерологическом порядке. Если задать несколько файлов, то команда `sort` соединит их и, рассортировав, выдаст единым выводом. По умолчанию, объектом сортировки будут строки, однако опции позволяют выбирать объект сортировки: колонки, столбцы и прочие элементы форматирования файла. Разделителем между ними служат пробелы, однако соответствующие опции позволяют задать иные разделители.

Команда `sort` весьма древняя, она может служить образцом программирования утилит в ранних 70-х годах прошлого века.
Составим список долгов и запишем их в файл dolgi.txt
**тут картинка**  
### Задача
Сделать сортировку по имени в алфавитном порядке.
### Команда
```bash
sort dolgi.txt'
```
### Результат
**тут картинка**  
Произошла сортировка имен в алфавитном порядке.

# Опции sort
## 1. Опция -r
### Задача
Эта опция позволяет сортировать файл в порядке обратном алфавитному.
### Команда
```bash
sort -r dolgi.txt
```
### Результат
**тут картинка**  
Произошла сортировка имен в порядке обратном алфавитному.
 