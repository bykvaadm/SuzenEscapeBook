# Фильтрование данных

**Фильтрация текста** – это процесс получения входного текстового потока, выполнения неких преобразований над ним и передача измененных данных в выходной поток. Хотя входные или выходные данные могут поступать из файлов, в UNIX® и Linux фильтрация обычно осуществляется путем составления конвейеров из команд, в которых вывод одной команды передается по программному каналу (или перенаправляется) на вход следующей команде.

К числу команд-фильтров относятся **grep**, **ack**, **awk**, **sort**, **uniq**, **ws**, **tr**. Далее рассмотрим их более подробно.

## Создание файлов

1. Переходим в директорию рабочего стола
2. Создаем папку **filtering**
3. Переходим в созданную директорию
4. Создаем файл **tanya.txt** в данной директории
5. Заносим данные в файл
6. Создаем файл **ksenya.txt** в данной директории
7. Заносим данные в файл

![filtering](../img/commands/filtering/1.png)

## grep

Команда **grep**, одна из самых известных и употребительных команд Unix-подобных ОС, ведет свое начало от первого текстового Unix-редактора - **ed**. В этом редакторе была команда **g/re/p** (*global/regular expression/print*), которая и дала свое название новой программе.

Утилита **grep** осуществляет во входных данных поиск строк, совпадающих с данным выражением (данными выражениями). Если строка ввода совпадает с любым из выражений, она считается "выбранной". По умолчанию выбранные строки записываются в стандартный поток вывода. 

Утилита **grep** распознает три типа регулярных выражений: базовые, расширенные и фиксированные.

Базовые и расширенные регулярные выражения аналогичны арифметическим выражениям, в которых крупные выражения формируются путем объединения более мелких выражений и операторов по установленному правилу приоритетов. В регулярных выражениях присутствует "невидимый" оператор, т.е. конкатенация. Конкатенация двух выражений означает сопоставление лево, а затем правой части. Наименьшим выражением является один символ. 

<ins>**Задача**</ins>

Команда **grep** может обрабатывать любое количество файлов одновременно. Возьмем два исходных файла, которые мы создали. 

```
grep ‘5’ tanya.txt ksenya.
```

![grep](../img/commands/filtering/2.png)

В выводе перечислены файлы, и указано, в каком из них какая строка содержит символ «5». Символ пришлось взять в кавычки, чтобы командный интерпретатор понял, что имеется в виду символ, а не условный знак.

Команда grep вовсе не ограничена одним выражением, можно задавать хоть целые фразы. Только их тоже нужно заключать в кавычки (одинарные или двойные):

```
grep ‘e f ’ tanya.txt ksenya.txt
```

![grep](../img/commands/filtering/3.png)

### Опции grep
---

<ins>**Опция -i (--ignore-case)**</ins>

Приказывает команде игнорировать регистр символов, таким образом, поиск будет производиться как среди заглавных, так и среди строчных букв.

```
grep –i ‘w’ tanya.txt ksenya.txt
```

![grep](../img/commands/filtering/4.png)

Изначально была задана строчная буква **'w'**, а на экран произошел вывод как строчных, так и заглавных букв **'w'**

<ins>**Опция -c (--count)**</ins>

Эта опция не выводит строки, а подсчитывает количество строк, в которых обнаружена заданная конфигурация символов.

```
grep –с ‘a’ tanya.txt ksenya.txt
```

![grep](../img/commands/filtering/5.png)

То есть в двух строках файла tanya.txt и трех строках файла ksenya.txt встречается сочетание символа «а».

<ins>**Опция -n (--line-number)**</ins>

При использовании этой опции вывод команды **grep** будет указывать номера строк, содержащих заданную конфигурацию.

```
grep –n ‘ou’ tanya.txt ksenya.txt
```

![grep](../img/commands/filtering/6.png)

Во второй и четвертой строках файла tanya.txt найдено сочетание ‘ou’

<ins>**Опция -v (--invert-match)**</ins>

Выполняет работу, обратную обычной - выводит строки, в которых заданная конфигурация не встречается.

```
grep -v 'ewq' tanya.txt ksenya.txt
```

![grep](../img/commands/filtering/7.png)

Во всех строках, которые выведены на экран, нет конфигурации символов **'ewq'**.

<ins>**Опция -w (--word-regexp)**</ins>

Заставит команду **grep** искать только строки, содержащие все слово или фразу, составляющую данную конфигурацию.

```
grep –w ‘ar’ tanya.txt ksenya.txt
```

![grep](../img/commands/filtering/8.png)

Вывода нет, то есть не нашлись строки, содержащих выражение "ar". А вот в данном случае:

![grep](../img/commands/filtering/9.png)  

Команда находит точное соответствие в файле tanya.txt.

<ins>**Опция -x (--line-regexp)**</ins>

Еще более строгая команда. Она отберет только те строки исследуемого файла или файлов, которые полностью совпадают с заданной конфигурацией.

```
grep –x ‘Woy’ tanya.txt ksenya.txt
```

![grep](../img/commands/filtering/10.png)  

Строгое совпадение нашлось только в файле *ksenya.txt*. Это строка **‘Woy’**

<ins>**Опция -l (--files-with-matches)**</ins>

Команда **grep** с этой опцией не возвращает строки, содержащие заданную конфигурацию, а сообщает лишь имена файлов, в которых данный образец найден.

```
Grep –l ‘Tanya’ tanya.txt ksenya.txt
```

![grep](../img/commands/filtering/11.png)  
  
Конфигурация символов ‘Tanya’ была найдена только в файле tanya.txt .

<ins>**Опция -L (--files-without-match)**</ins>

Эта команда наоборот, сообщает имена тех файлов, где не встретилась заданная конфигурация.

```
Grep – L ‘Tanya’ tanya.txt ksenya.txt
```

![grep](../img/commands/filtering/12.png)  

Конфигурация символов ‘Tanya’ была не найдена только в файле ksenya.txt

## ack

Инструмент ack был разработан специально для поиска исходного кода программ. Потому ack ищет определенные файлы и игнорирует другие.

Для начала нужно установить инструмент ack на сервер. На сервере Ubuntu или Debian это так же просто, как установить утилиту из репозитория по умолчанию. Пакет называется **ack-grep**:

```
sudo apt update
sudo apt install ack-grep
```

Поскольку исполняемый файл также называется **ack-grep**, можно сказать системе сократить его имя до **ack**, чтобы использовать его в командной строке, введя следующую команду:
```
dpkg-divert --local --divert /usr/bin/ack --rename --add /usr/bin/ack-grep
```
Теперь инструмент будет отвечать на имя **ack** вместо **ack-grep**. 


Вывести файлы в которых был найден указанный шаблон.

```
ack w
```

![act](../img/commands/filtering/13.png)

Данная команда нашла все файлы, в которых встречается шаблон **'w'**.

### Опции ack
---

<ins>**Опция -f**</ins>

Узнать количество файлов в директории, в которой мы сейчас находимся.

```
ack -f | wc -l
```

![act](../img/commands/filtering/13_1.png)

В данной директории было найдено 4 файла.

<ins>**Опция -w**</ins>

Найти файлы, в которых слова четко совпадают с границами шаблона. 

```
ack -w We
```

![act](../img/commands/filtering/14.png)

Точное совпадение нашлось только в файле `tanya.txt`.

<ins>**Опция -ch**</ins>

Узнать общее количество найденных совпадений с шаблоном в файлах.

```
ack -ch a
```

![act](../img/commands/filtering/15.png)

В файлах, данной директории, нашлось 19 совпадений указанного шаблона **'a'**.

<ins>**Опция -c**</ins>

Узнать количество совпадений с шаблоном в каждом файле.

```
ack -c a
```

![act](../img/commands/filtering/16.png)  

Шаблон “а” был встречен в файле **'ksenya.txt'** 5 раз, в файле **povtor.txt** 0 раз , в файлах **dolgi.txt** и **tanya.txt** по 7 раз.


# 4. awk

С помощью языка программирования **awk** можно выполнять следующие действия:

* объявлять переменные для хранения данных;
* использовать арифметические и строковые операторы для работы с данными;
* использовать структурные элементы и управляющие конструкции языка, такие, как оператор **if-then** и циклы, что позволяет реализовать сложные алгоритмы обработки данных;
* создавать форматированные отчёты.

Если говорить лишь о возможности создавать форматированные отчёты, которые удобно читать и анализировать, то это оказывается очень кстати при работе с лог-файлами, которые могут содержать миллионы записей. Но **awk** — это намного больше, чем средство подготовки отчётов.

Схема вызова **awk** выглядит так:
```
awk options program file
```
**Awk** воспринимает поступающие к нему данные в виде набора записей. Записи представляют собой наборы полей. Упрощенно, если не учитывать возможности настройки **awk** и говорить о некоем вполне обычном тексте, строки которого разделены символами перевода строки, запись — это строка. Поле — это слово в строке.

Одна из основных функций **awk** заключается в возможности манипулировать данными в текстовых файлах. Делается это путём автоматического назначения переменной каждому элементу в строке. По умолчанию **awk** назначает следующие переменные каждому полю данных, обнаруженному им в записи:

```
$0 — представляет всю строку текста (запись).
$1 — первое поле.
$2 — второе поле.
$n — n-ное поле.
```

Поля выделяются из текста с использованием символа-разделителя. По умолчанию — это пробельные символы вроде пробела или символа табуляции.

Рассмотрим использование этих переменных на простом примере. А именно, обработаем файл, в котором содержится несколько строк.


Вывести только первый столбец в указанном файле. Где разделителем столбцов по умолчанию считается пробел. 

```
awk '{print $1}' ksenya.txt
```

![awk](../img/commands/filtering/17.png)

Данная команда вывела первые слова (первые поля) каждой записи, содержащиеся в файле `ksenya.txt`.

### Опции awk
---

<ins>**Опция -F**</ins>

Вывести поля, в которых используется указанный в команде разделитель. Текст файла text.txt:

```
Hello, my name is Ksenya.
My friends is Tanya, Lina, Julia, Poly.
```

В качестве разделителя зададим символ **','**.

```
awk -F, '{print $1}' text.txt
```

![awk](../img/commands/filtering/19.png)

Данная команда вывела первые поля файла `text.txt`, считая в качестве символа разделителя (конца поля) символ **','**.

<ins>**Опция -v**</ins>

Передать в программу переменную, а именно константу.

```
awk -v pi=3.1415 '{print $1}'
```

![awk](../img/commands/filtering/20.png)

В результате работы команды было выведено число, занесённое нами в константу.

<ins>**Опция -f**</ins>

Использовать скрипты, хранящиеся в файлах, и обратиться к ним в команде.

Подготовим файл text1.txt, в который запишем следующее содержимое:

```
{print $1 "*" $2}
```

Вызовем awk, указав этот файл в качестве источника команд

```
awk -F, -f text1.txt text.txt'
```

![awk](../img/commands/filtering/22.png)

В качестве разделителя строк мы указали символ \*\*','\*\*. Поэтому в ходе выполнения команды, между первым и вторым полем разделитель поменялся на символ \*\*'\*'\*\*, который мы указали в файле источника команд `text1.txt`.

## 4. length

Получить длину каждой строки, использую ключ **length**.

```
awk '{print length}' text.txt'
```

![awk](../img/commands/filtering/23.png) 

В файле text.txt, в первом предложении количество символов **25**, во втором **39**.

## 4. BEGIN/END

Вывести перед файлом и после него указанные данные.

```
awk 'BEGIN {print "--------------------"} {print $0} END {print "BYE"}' text.txt'
```

![awk](../img/commands/filtering/24.png)   

В результате выполнения данной команды, в начало и конец файла **text.txt**, который мы выводим полностью (указав **$0**), будут добавлены строки указанные в команде.

**awk** - это мощнейший инструмент обработки данных, масштабы которого сопоставимы с отдельным языком программирования.

## sort
Команда **sort** сортирует содержимое файла в алфавитном или нумерологическом порядке. Если задать несколько файлов, то команда **sort** соединит их и, рассортировав, выдаст единым выводом. По умолчанию, объектом сортировки будут строки, однако опции позволяют выбирать объект сортировки: колонки, столбцы и прочие элементы форматирования файла. Разделителем между ними служат пробелы, однако соответствующие опции позволяют задать иные разделители.

Команда **sort** весьма древняя, она может служить образцом программирования утилит в ранних 70-х годах прошлого века.

Составим список долгов и запишем их в файл dolgi.txt

![awk](../img/commands/filtering/25.png) 

Сделать сортировку по имени в алфавитном порядке.

```
sort dolgi.txt'
```

![awk](../img/commands/filtering/26.png) 

Произошла сортировка имен в алфавитном порядке.

### Опции sort

<ins>**Опция -r**</ins>

Эта опция позволяет сортировать файл в порядке обратном алфавитному.

```
sort -r dolgi.txt
```

![awk](../img/commands/filtering/27.png) 

Произошла сортировка имен в порядке обратном алфавитному.
 
<ins>**Опция –k и опция –n**</ins>

Приходится рассматривать эти две опции вместе, так как они позволяют сразу показать весь спектр опций. 

Опция -n используется всегда, когда нужно сортировать числа, разумеется в порядке возрастания (или убывания, авив опцию -r).

Опция -k позволяет задавать объект сортировки: все эти столбцы, колонки, и тому подобные элементы матирования файла.

```
sort –nrk 2 dolgi.txt
```

Итак, можно выявить самых злостных должников по мере убывания долга.

![awk](../img/commands/filtering/28.png) 

Опция -n сообщает команде, что сортировать придется числа, опция -r , что в обратном порядке, а опция -k задает объект - вторую колонку текста.

<ins>**Опция –m (--month-sort)**</ins>

Одной удивительной способностью команды sort является то, что она может сортировать даже месяцы.

```
sort –k 4M dolgi.txt
```

Названия месяцев находятся в 4 колонке.

![awk](../img/commands/filtering/29.png) 

Опция М преобразует первые три непробельныx символа указанного столбца в заглавные буквы (Скажем, SEP означает SEPtember), а затем сравнивает их и располагает в порядке годового круга.

<ins>**Опция –u (--unique)**</ins>

Скрывает одинаковые объекты. Если в процессе сортировки выявилось несколько одинаковых объектов, то будет выведен только первый из них, остальные проигнорированы.

```
sort  -uk 1,1 dolgi.txt
```

Начальный файл:

![awk](../img/commands/filtering/30.png) 

Результат

![awk](../img/commands/filtering/31.png) 

Первая единица означает начало объекта сортировки (*колонки текста*), а вторая единица через запятую - конец объекта сортировки. То есть команде запрещено использовать для сортировки символы после последней буквы первой колонки.

Как оказалось, пользоваться утилитой **sort** для сортировки вывода предельно просто. Это полезная команда, с помощью которой не проблема выявить в огромной директории файлы, которые когда-то потерялись, или собрать в едино все ссылки, чтобы их проверить и так далее.

## Uniq
**Uniq** — утилита Unix, с помощью которой можно вывести или отфильтровать повторяющиеся строки в файле. Если входной файл задан как («-») или не задан вовсе, чтение производится из стандартного ввода. Если выходной файл не задан, запись производится в стандартный вывод. Вторая и последующие копии повторяющихся соседних строк не записываются. Повторяющиеся входные строки не распознаются, если они не следуют строго друг за другом, поэтому может потребоваться предварительная сортировка файлов.

Если в тексте следует подряд несколько одинаковых строк, то команда uniq уменьшит их количество до одной.

```
Cat povtor.txt | sort | uniq
```

Начальный файл:
 
![uniq](../img/commands/filtering/32.png) 

Результат:

![uniq](../img/commands/filtering/33.png) 

 
Мы используем cat для отправки содержимого povtor.txt команде sort. Когда sort получает данные на вход, она сортирует их построчно в алфавитном порядке, и отправляет в таком виде программе uniq. uniq удаляет повторяющиеся строки. Тут нужно уточнить очень интересную вещь: команда uniq сравнивает только рядом расположенные строчки.  Становится понятным, что команда uniq любит уже отсортированные тексты, где все одинаковые строчки собраны вместе.

### Опции uniq
---

<ins>**Опция –c**</ins>

--count

Сообщить, сколько было одинаковых строк до их урезания.

```
Cat povtor.txt | sort | uniq -c
```

![uniq](../img/commands/filtering/34.png) 
 
Например, для строки «1234» было 2 совпадения.

<ins>**Опция –d**</ins>

--repeated

Эта опция, наоборот, выведет лишь ту строку, которая повторялась в тексте.

```
Cat povtor.txt | sort | uniq -d
```

![uniq](../img/commands/filtering/35.png) 
 
На экране строки, которые повторились в тексте два и более раз.

<ins>**Опция –u**</ins>

--unique

Выводит только уникальные строки.

```
Cat povtor.txt | sort | uniq –u 
```

![uniq](../img/commands/filtering/36.png) 

На экране уникальные строки.

<ins>**Опция –D**</ins>

--all-repeated

Выведет все повторяющиеся строки, не уменьшая их числа.

```
Cat povtor.txt | sort | uniq -D
```

![uniq](../img/commands/filtering/37.png) 

 
На экране строки, которые повторялись несколько раз, при этом количество повторений сохранено.

Uniq хорошая команда для обработки файлов, когда есть повторяющиеся строки. Для работы с файлами без повторений лучше использовать команду **sort**.

## Wс

С помощью команды **wc** можно подсчитать число строк, слов и символов в указанном файле. Если указано более одного файла в командной строке, то программа wc осуществляет подсчет строк, слов и символов в каждом файле и затем выдает общее число. 

Подсчитать число строк, слов и символов в указанном файле.

```
wс file
```

![uniq](../img/commands/filtering/38.png) 

### Опции wc
---

<ins>**Опция-l**</ins>

Вывести количество строк в указанном файле.

```
wс –l tanya.txt
```

![uniq](../img/commands/filtering/39.png) 
В файле tanya.txt четыре строки.

<ins>**Опция-w**</ins>

Вывести количество слов в указанном файле. 

``` 
wс –w ksenya.txt
```

![uniq](../img/commands/filtering/40.png)
 
В файле ksenya.txt 16 строк.

<ins>**Опция-c**</ins>

Вывести количество символов в указанных файлах.

```
wс –c ksenya.txt tanya.txt
```

![uniq](../img/commands/filtering/41.png)
 
В файле **ksenya.txt**  78 символов, а в файле **tanya.txt** 80. Общее количество символов в файле 158.

Команда **wc** хороший помощник в подсчете количества строк, слов и символов. Эти данные смогут помочь нам в дальнейшей работе с файлами.

## Tr

**Команда tr** служит для перевода (замены) выбранных символов в другие символы или удаления их.

В отличие от большинства других программ командной строки, **команда tr** не принимает имен файлов в качестве аргумента. Ввод команды tr осуществляется или со стандартного ввода, или с вывода других программ путем перенаправления.

**Команде tr** требуется минимум один аргумент, а принимается максимум два. Первый аргумент, называемый набор1 перечисляет символы, подлежащие замене или удалению. Второй аргумент, набор2, перечисляет символы, которые должны заменить символы из набора1.

**Команда tr** без опций заменит символы из набора1 символами из набора2.
Задача: Заменим все буквы a на буквы b. Для этого введем tr a b. Затем следует нажать Enter и команда будет готова к приему текста. Когда текс введен, то необходимо снова нажать Enter и так до бесконечности, пока необходимо будет заменять буквы в тексте. Когда нужно будет выйти из команды надо нажать клавиши *Ctrl+C*.

```
tr a b 
```

![uniq](../img/commands/filtering/42.png)
 
### Опции tr
---

<ins>**Опция –s**</ins>

Это одна из самых полезных опций команды **tr**. Эта опция позволяет заменить повторяющиеся подряд символы из набора1 на единственный символ из списка2. Если список 2 отсутствует, то заменяет множественные символы одиночными. Чаще всего эта уплотняющая текст опция применяется для замены множественных пробелов на один единственный.

```
Cat tanya.txt | tr –s “ “ “@”
```

![uniq](../img/commands/filtering/43.png)
 
Здесь заменили все пробелы, служащие разделителями в файле **tanya.txt** на собаку.

<ins>**Опция –d**</ins>

Используется для удаления из текста символов, перечисленных в наборе1.

```
Cat tanya.txt | tr –d a
```

![uniq](../img/commands/filtering/44.png)	
 
В примере удалились все символы «а» из файла **tanya.txt**

Опция может удалять также специальные символы, например, символ возврата каретки, который заканчивает строку в паре с символом новой строки в файлах *ОС Windows*. После его удаления останется только символ новой строки, который использует Юникс.

<ins>**Опция –c/cd**</ins>

Заставляет команду работать с символами, которые отсутствуют в наборе 1. Другими словами: символы, перечисленные в наборе1 не используются в работе, а все остальные - используются. 

```
cat tanya.txt | tr –cd b-z[ :cntrl: ] [ :blank: ]
```

![uniq](../img/commands/filtering/45.png)

В этом примере нет буквы а, вот ее и будет удалять программа. Символы из группы **[:cntrl:]** нужно указать, чтобы их не удалили, иначе не происходит перенос строки, а пробел - **[:blank:]** - указать, чтобы он тоже остался на месте.

Программа **tr** дает удивительные возможности изменять файлы, порой до неузнаваемости, простыми методами. Трудно предсказать, какое применение команде может найти пользователь, знающий ее тонкости. 
